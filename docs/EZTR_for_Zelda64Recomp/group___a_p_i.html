<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EZ Text Replacer for Zelda64Recompiled: - Basic</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">EZ Text Replacer for Zelda64Recompiled<span id="projectnumber">&#160;2.0.0</span>
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group___a_p_i.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">- Basic</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8001f916103311b701e403d62f776074" id="r_ga8001f916103311b701e403d62f776074"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8001f916103311b701e403d62f776074">EZTR_Basic_ReplaceBuffer</a> (u16 textId, <a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf, <a class="el" href="eztr__api_8h.html#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a> callback)</td></tr>
<tr class="memdesc:ga8001f916103311b701e403d62f776074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a replacement of a vanilla message by copying from a buffer defined by the user.  <br /></td></tr>
<tr class="separator:ga8001f916103311b701e403d62f776074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga130700fec5bb6f9469a5c41847f2fbb6" id="r_ga130700fec5bb6f9469a5c41847f2fbb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga130700fec5bb6f9469a5c41847f2fbb6">EZTR_Basic_ReplaceText</a> (u16 textId, u8 text_box_type, u8 text_box_y_pos, u8 display_icon, u16 next_message_id, u16 first_item_rupees, u16 second_item_rupees, bool pipe_escape_bytes, char *content, <a class="el" href="eztr__api_8h.html#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a> callback)</td></tr>
<tr class="memdesc:ga130700fec5bb6f9469a5c41847f2fbb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a replacement of a vanilla message by defining the header attributes and message content.  <br /></td></tr>
<tr class="separator:ga130700fec5bb6f9469a5c41847f2fbb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c3d2fef5e69105140806673fce4d985" id="r_ga2c3d2fef5e69105140806673fce4d985"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2c3d2fef5e69105140806673fce4d985">EZTR_Basic_ReplaceTextEmpty</a> (u16 textId, <a class="el" href="eztr__api_8h.html#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a> callback)</td></tr>
<tr class="memdesc:ga2c3d2fef5e69105140806673fce4d985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a replacement of a vanilla message, where the replacement message is empty.  <br /></td></tr>
<tr class="separator:ga2c3d2fef5e69105140806673fce4d985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae288fd74c3f0df7ebafbbd4f795a68f6" id="r_gae288fd74c3f0df7ebafbbd4f795a68f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae288fd74c3f0df7ebafbbd4f795a68f6">EZTR_Basic_AddCustomBuffer</a> (<a class="el" href="eztr__api_8h.html#af14c939010aeb8ff548788278b5e1b0f">EZTR_CustomMsgHandle</a> handle, <a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf, <a class="el" href="eztr__api_8h.html#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a> callback)</td></tr>
<tr class="memdesc:gae288fd74c3f0df7ebafbbd4f795a68f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a brand new (i.e: custom) message by copying from a buffer defined by the user.  <br /></td></tr>
<tr class="separator:gae288fd74c3f0df7ebafbbd4f795a68f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba5d26d7477edd4ba4ec2be15766e136" id="r_gaba5d26d7477edd4ba4ec2be15766e136"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaba5d26d7477edd4ba4ec2be15766e136">EZTR_Basic_AddCustomText</a> (<a class="el" href="eztr__api_8h.html#af14c939010aeb8ff548788278b5e1b0f">EZTR_CustomMsgHandle</a> handle, u8 text_box_type, u8 text_box_y_pos, u8 display_icon, u16 next_message_id, u16 first_item_rupees, u16 second_item_rupees, bool pipe_escape_bytes, char *content, <a class="el" href="eztr__api_8h.html#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a> callback)</td></tr>
<tr class="memdesc:gaba5d26d7477edd4ba4ec2be15766e136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a brand new (i.e: custom) message by defining the header attributes and message content.  <br /></td></tr>
<tr class="separator:gaba5d26d7477edd4ba4ec2be15766e136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed8bd9e796160a2657adf03a77703baf" id="r_gaed8bd9e796160a2657adf03a77703baf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaed8bd9e796160a2657adf03a77703baf">EZTR_Basic_AddCustomTextEmpty</a> (<a class="el" href="eztr__api_8h.html#af14c939010aeb8ff548788278b5e1b0f">EZTR_CustomMsgHandle</a> handle, <a class="el" href="eztr__api_8h.html#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a> callback)</td></tr>
<tr class="memdesc:gaed8bd9e796160a2657adf03a77703baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a brand new (i.e: custom) message, where the replacement message is empty.  <br /></td></tr>
<tr class="separator:gaed8bd9e796160a2657adf03a77703baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52a12f735129bbe48bc0780c47fa7665" id="r_ga52a12f735129bbe48bc0780c47fa7665"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga52a12f735129bbe48bc0780c47fa7665">EZTR_Basic_ReplaceCustomBuffer</a> (<a class="el" href="eztr__api_8h.html#af14c939010aeb8ff548788278b5e1b0f">EZTR_CustomMsgHandle</a> handle, <a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf, <a class="el" href="eztr__api_8h.html#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a> callback)</td></tr>
<tr class="memdesc:ga52a12f735129bbe48bc0780c47fa7665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a replacement for a custom message by copying from a buffer defined by the user.  <br /></td></tr>
<tr class="separator:ga52a12f735129bbe48bc0780c47fa7665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc25b8ecceac76911ea9dfc91d94d9e8" id="r_gabc25b8ecceac76911ea9dfc91d94d9e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabc25b8ecceac76911ea9dfc91d94d9e8">EZTR_Basic_ReplaceCustomText</a> (<a class="el" href="eztr__api_8h.html#af14c939010aeb8ff548788278b5e1b0f">EZTR_CustomMsgHandle</a> handle, u8 text_box_type, u8 text_box_y_pos, u8 display_icon, u16 next_message_id, u16 first_item_rupees, u16 second_item_rupees, bool pipe_escape_bytes, char *content, <a class="el" href="eztr__api_8h.html#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a> callback)</td></tr>
<tr class="memdesc:gabc25b8ecceac76911ea9dfc91d94d9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a replacement of a custom message by defining the header attributes and message content.  <br /></td></tr>
<tr class="separator:gabc25b8ecceac76911ea9dfc91d94d9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39c2beef126a75f0222b69759008120e" id="r_ga39c2beef126a75f0222b69759008120e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga39c2beef126a75f0222b69759008120e">EZTR_MsgBuffer_Create</a> ()</td></tr>
<tr class="memdesc:ga39c2beef126a75f0222b69759008120e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new message buffer object on the heap.  <br /></td></tr>
<tr class="separator:ga39c2beef126a75f0222b69759008120e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09fc35479c7e6fee9e6049f473363177" id="r_ga09fc35479c7e6fee9e6049f473363177"><td class="memItemLeft" align="right" valign="top"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga09fc35479c7e6fee9e6049f473363177">EZTR_MsgBuffer_CreateFromStr</a> (char *src)</td></tr>
<tr class="memdesc:ga09fc35479c7e6fee9e6049f473363177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new message buffer object on the heap, and copies <code>src</code> into it.  <br /></td></tr>
<tr class="separator:ga09fc35479c7e6fee9e6049f473363177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91896add7333589c5d04730e84c8f6f4" id="r_ga91896add7333589c5d04730e84c8f6f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga91896add7333589c5d04730e84c8f6f4">EZTR_MsgBuffer_CreateFromStrN</a> (char *src, size_t len)</td></tr>
<tr class="memdesc:ga91896add7333589c5d04730e84c8f6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new message buffer object on the heap, and copies <code>src</code> into it for up to <code>len</code> bytes.  <br /></td></tr>
<tr class="separator:ga91896add7333589c5d04730e84c8f6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27b268a005666834e39511fd0dc2c469" id="r_ga27b268a005666834e39511fd0dc2c469"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga27b268a005666834e39511fd0dc2c469">EZTR_MsgBuffer_Destroy</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf)</td></tr>
<tr class="memdesc:ga27b268a005666834e39511fd0dc2c469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees/destroys a message buffer.  <br /></td></tr>
<tr class="separator:ga27b268a005666834e39511fd0dc2c469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga020cddc8868430e6afd77733907d6139" id="r_ga020cddc8868430e6afd77733907d6139"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga020cddc8868430e6afd77733907d6139">EZTR_MsgBuffer_Copy</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *dst, char *src)</td></tr>
<tr class="memdesc:ga020cddc8868430e6afd77733907d6139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from <code>src</code> into the message buffer <code>dst</code>.  <br /></td></tr>
<tr class="separator:ga020cddc8868430e6afd77733907d6139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa46abdcae0cc0572a9b3d6474f01bc62" id="r_gaa46abdcae0cc0572a9b3d6474f01bc62"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa46abdcae0cc0572a9b3d6474f01bc62">EZTR_MsgBuffer_NCopy</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *dst, char *src, size_t len)</td></tr>
<tr class="memdesc:gaa46abdcae0cc0572a9b3d6474f01bc62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from <code>src</code> into the message buffer <code>dst</code>, up to <code>len</code> bytes.  <br /></td></tr>
<tr class="separator:gaa46abdcae0cc0572a9b3d6474f01bc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b931bdaf93270ddc7ed445cf699b1fe" id="r_ga8b931bdaf93270ddc7ed445cf699b1fe"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8b931bdaf93270ddc7ed445cf699b1fe">EZTR_MsgBuffer_Len</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf)</td></tr>
<tr class="memdesc:ga8b931bdaf93270ddc7ed445cf699b1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the message buffer's stored data, in bytes.  <br /></td></tr>
<tr class="separator:ga8b931bdaf93270ddc7ed445cf699b1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4370a73be9636af6f60dfb954342cedc" id="r_ga4370a73be9636af6f60dfb954342cedc"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4370a73be9636af6f60dfb954342cedc">EZTR_MsgBuffer_ContentLen</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf)</td></tr>
<tr class="memdesc:ga4370a73be9636af6f60dfb954342cedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the message buffer's content region, in bytes.  <br /></td></tr>
<tr class="separator:ga4370a73be9636af6f60dfb954342cedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad149fb2e9d2c8fa3e0034ac54a61a678" id="r_gad149fb2e9d2c8fa3e0034ac54a61a678"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad149fb2e9d2c8fa3e0034ac54a61a678">EZTR_MsgBuffer_WriteDefaultHeader</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf)</td></tr>
<tr class="memdesc:gad149fb2e9d2c8fa3e0034ac54a61a678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a message buffer's header to default values.  <br /></td></tr>
<tr class="separator:gad149fb2e9d2c8fa3e0034ac54a61a678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga578d94107d666a42c08bb3ad73fd8f33" id="r_ga578d94107d666a42c08bb3ad73fd8f33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga578d94107d666a42c08bb3ad73fd8f33">EZTR_MsgBuffer_WriteHeader</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf, u8 text_box_type, u8 text_box_y_pos, u8 display_icon, u16 next_message_id, u16 first_item_rupees, u16 second_item_rupees)</td></tr>
<tr class="separator:ga578d94107d666a42c08bb3ad73fd8f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fa740d70e876eb91c758c0686f06cb6" id="r_ga6fa740d70e876eb91c758c0686f06cb6"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6fa740d70e876eb91c758c0686f06cb6">EZTR_MsgBuffer_GetTextBoxType</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf)</td></tr>
<tr class="memdesc:ga6fa740d70e876eb91c758c0686f06cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the text_box_type from a message buffer's header.  <br /></td></tr>
<tr class="separator:ga6fa740d70e876eb91c758c0686f06cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga530d275045043f28d94b762b36daf66e" id="r_ga530d275045043f28d94b762b36daf66e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga530d275045043f28d94b762b36daf66e">EZTR_MsgBuffer_SetTextBoxType</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf, u8 type)</td></tr>
<tr class="memdesc:ga530d275045043f28d94b762b36daf66e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the text_box_type of the message buffer's header.  <br /></td></tr>
<tr class="separator:ga530d275045043f28d94b762b36daf66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb5e6b7691b750e998d5258cd180ef8e" id="r_gacb5e6b7691b750e998d5258cd180ef8e"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacb5e6b7691b750e998d5258cd180ef8e">EZTR_MsgBuffer_GetTextBoxYPos</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf)</td></tr>
<tr class="memdesc:gacb5e6b7691b750e998d5258cd180ef8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the text_box_y_pos from a message buffer's header.  <br /></td></tr>
<tr class="separator:gacb5e6b7691b750e998d5258cd180ef8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaf1d5e1b0fc9637427f0c758bff0da9" id="r_gabaf1d5e1b0fc9637427f0c758bff0da9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabaf1d5e1b0fc9637427f0c758bff0da9">EZTR_MsgBuffer_SetTextBoxYPos</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf, u8 pos)</td></tr>
<tr class="memdesc:gabaf1d5e1b0fc9637427f0c758bff0da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the text_box_y_pos of the message buffer's header.  <br /></td></tr>
<tr class="separator:gabaf1d5e1b0fc9637427f0c758bff0da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bc50f85b99782d5aa97f8d122d1587d" id="r_ga4bc50f85b99782d5aa97f8d122d1587d"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4bc50f85b99782d5aa97f8d122d1587d">EZTR_MsgBuffer_GetTextBoxDisplayIcon</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf)</td></tr>
<tr class="memdesc:ga4bc50f85b99782d5aa97f8d122d1587d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the display_icon from a message buffer's header.  <br /></td></tr>
<tr class="separator:ga4bc50f85b99782d5aa97f8d122d1587d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf6d8ba4bde04faab7330540c4d284cd" id="r_gacf6d8ba4bde04faab7330540c4d284cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacf6d8ba4bde04faab7330540c4d284cd">EZTR_MsgBuffer_SetTextBoxDisplayIcon</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf, u8 icon)</td></tr>
<tr class="memdesc:gacf6d8ba4bde04faab7330540c4d284cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the display_icon of the message buffer's header.  <br /></td></tr>
<tr class="separator:gacf6d8ba4bde04faab7330540c4d284cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga015f838b68601c44d38be12780cb0834" id="r_ga015f838b68601c44d38be12780cb0834"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga015f838b68601c44d38be12780cb0834">EZTR_MsgBuffer_GetNextMsg</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf)</td></tr>
<tr class="memdesc:ga015f838b68601c44d38be12780cb0834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the next_message_id from a message buffer's header.  <br /></td></tr>
<tr class="separator:ga015f838b68601c44d38be12780cb0834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46f857fd4054f0b076012a85b8b14f08" id="r_ga46f857fd4054f0b076012a85b8b14f08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga46f857fd4054f0b076012a85b8b14f08">EZTR_MsgBuffer_SetNextMsg</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf, u16 textId)</td></tr>
<tr class="memdesc:ga46f857fd4054f0b076012a85b8b14f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the next_message_id of the message buffer's header.  <br /></td></tr>
<tr class="separator:ga46f857fd4054f0b076012a85b8b14f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecbd0e2114b2169dac0254e15bb920f4" id="r_gaecbd0e2114b2169dac0254e15bb920f4"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaecbd0e2114b2169dac0254e15bb920f4">EZTR_MsgBuffer_GetFirstItemRupees</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf)</td></tr>
<tr class="memdesc:gaecbd0e2114b2169dac0254e15bb920f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the first_item_rupees from a message buffer's header.  <br /></td></tr>
<tr class="separator:gaecbd0e2114b2169dac0254e15bb920f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89663200d1aa9ffe42c27039bb2701d4" id="r_ga89663200d1aa9ffe42c27039bb2701d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga89663200d1aa9ffe42c27039bb2701d4">EZTR_MsgBuffer_SetFirstItemRupees</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf, u16 val)</td></tr>
<tr class="memdesc:ga89663200d1aa9ffe42c27039bb2701d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the first_item_rupees of the message buffer's header.  <br /></td></tr>
<tr class="separator:ga89663200d1aa9ffe42c27039bb2701d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2894fa932a1b5ab0429b26395eca921" id="r_gaa2894fa932a1b5ab0429b26395eca921"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa2894fa932a1b5ab0429b26395eca921">EZTR_MsgBuffer_GetSecondItemRupees</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf)</td></tr>
<tr class="memdesc:gaa2894fa932a1b5ab0429b26395eca921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the second_item_rupees from a message buffer's header.  <br /></td></tr>
<tr class="separator:gaa2894fa932a1b5ab0429b26395eca921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga873aabed87f63550b8818174e16f7f63" id="r_ga873aabed87f63550b8818174e16f7f63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga873aabed87f63550b8818174e16f7f63">EZTR_MsgBuffer_SetSecondItemRupees</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf, u16 val)</td></tr>
<tr class="memdesc:ga873aabed87f63550b8818174e16f7f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the second_item_rupees of the message buffer's header.  <br /></td></tr>
<tr class="separator:ga873aabed87f63550b8818174e16f7f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8d9e959cd5fa20e5bdadb8cce347c22" id="r_gaf8d9e959cd5fa20e5bdadb8cce347c22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf8d9e959cd5fa20e5bdadb8cce347c22">EZTR_MsgBuffer_Print</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf)</td></tr>
<tr class="memdesc:gaf8d9e959cd5fa20e5bdadb8cce347c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the contents of a message buffer to the console.  <br /></td></tr>
<tr class="separator:gaf8d9e959cd5fa20e5bdadb8cce347c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59379a5596f63ec6c0bcd7eb4fb7fd14" id="r_ga59379a5596f63ec6c0bcd7eb4fb7fd14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga59379a5596f63ec6c0bcd7eb4fb7fd14">EZTR_MsgBuffer_PrintFull</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf)</td></tr>
<tr class="memdesc:ga59379a5596f63ec6c0bcd7eb4fb7fd14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the contents of a message buffer to the console.  <br /></td></tr>
<tr class="separator:ga59379a5596f63ec6c0bcd7eb4fb7fd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21eec47bd44a5a81b37aa88561d17146" id="r_ga21eec47bd44a5a81b37aa88561d17146"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga21eec47bd44a5a81b37aa88561d17146">EZTR_MsgBuffer_GetContentPtr</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf)</td></tr>
<tr class="memdesc:ga21eec47bd44a5a81b37aa88561d17146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to the beginning of the content region for a desired message buffer.  <br /></td></tr>
<tr class="separator:ga21eec47bd44a5a81b37aa88561d17146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cdf97a6b5c9d99e1154d1709e6f2dc4" id="r_ga9cdf97a6b5c9d99e1154d1709e6f2dc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9cdf97a6b5c9d99e1154d1709e6f2dc4">EZTR_MsgSContent_SetEmpty</a> (char *cont)</td></tr>
<tr class="memdesc:ga9cdf97a6b5c9d99e1154d1709e6f2dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the message message content as empty.A_BTN_STATE_IDLE.  <br /></td></tr>
<tr class="separator:ga9cdf97a6b5c9d99e1154d1709e6f2dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffede5c9bbcd94fcedf72680c6ac3666" id="r_gaffede5c9bbcd94fcedf72680c6ac3666"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaffede5c9bbcd94fcedf72680c6ac3666">EZTR_MsgSContent_Len</a> (char *cont)</td></tr>
<tr class="memdesc:gaffede5c9bbcd94fcedf72680c6ac3666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the length of the a message content string in bytes, not counting the '\xBF' termination character.  <br /></td></tr>
<tr class="separator:gaffede5c9bbcd94fcedf72680c6ac3666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga942c2f98af6fe2a81428bdcfd8336183" id="r_ga942c2f98af6fe2a81428bdcfd8336183"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga942c2f98af6fe2a81428bdcfd8336183">EZTR_MsgSContent_NCopy</a> (char *dst, char *src, size_t len)</td></tr>
<tr class="memdesc:ga942c2f98af6fe2a81428bdcfd8336183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies message content from <code>src</code> into the <code>dst</code>, up to <code>len</code> bytes.  <br /></td></tr>
<tr class="separator:ga942c2f98af6fe2a81428bdcfd8336183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga663aa64051a106585368bd080dbfac91" id="r_ga663aa64051a106585368bd080dbfac91"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga663aa64051a106585368bd080dbfac91">EZTR_MsgSContent_Copy</a> (char *dst, char *src)</td></tr>
<tr class="memdesc:ga663aa64051a106585368bd080dbfac91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies message content from <code>src</code> into the <code>dst</code>.  <br /></td></tr>
<tr class="separator:ga663aa64051a106585368bd080dbfac91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa144e4595b017537667babed825e67eb" id="r_gaa144e4595b017537667babed825e67eb"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa144e4595b017537667babed825e67eb">EZTR_MsgSContent_NCat</a> (char *dst, char *src, size_t len)</td></tr>
<tr class="memdesc:gaa144e4595b017537667babed825e67eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the message content of <code>src</code> onto the end of <code>dst</code>, up to <code>len</code> bytes from <code>src</code>.  <br /></td></tr>
<tr class="separator:gaa144e4595b017537667babed825e67eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72647d2cb1cbb660f9cb86df6074241f" id="r_ga72647d2cb1cbb660f9cb86df6074241f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga72647d2cb1cbb660f9cb86df6074241f">EZTR_MsgSContent_Cat</a> (char *dst, char *src)</td></tr>
<tr class="memdesc:ga72647d2cb1cbb660f9cb86df6074241f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the message content of <code>src</code> onto the end of <code>dst</code>.  <br /></td></tr>
<tr class="separator:ga72647d2cb1cbb660f9cb86df6074241f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79545ea629e4fb127ad978a8518c310f" id="r_ga79545ea629e4fb127ad978a8518c310f"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga79545ea629e4fb127ad978a8518c310f">EZTR_MsgSContent_NCmp</a> (char *str1, char *str2, size_t len)</td></tr>
<tr class="memdesc:ga79545ea629e4fb127ad978a8518c310f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares up to <code>len</code> bytes of two message content strings.  <br /></td></tr>
<tr class="separator:ga79545ea629e4fb127ad978a8518c310f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedf2e411789c0ad0061471c74ba87204" id="r_gaedf2e411789c0ad0061471c74ba87204"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaedf2e411789c0ad0061471c74ba87204">EZTR_MsgSContent_Cmp</a> (char *str1, char *str2)</td></tr>
<tr class="memdesc:gaedf2e411789c0ad0061471c74ba87204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two message content strings.  <br /></td></tr>
<tr class="separator:gaedf2e411789c0ad0061471c74ba87204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37a90a7c7b0c76188aedb8da5a39ec08" id="r_ga37a90a7c7b0c76188aedb8da5a39ec08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga37a90a7c7b0c76188aedb8da5a39ec08">EZTR_MsgSContent_Printf</a> (const char *format,...)</td></tr>
<tr class="memdesc:ga37a90a7c7b0c76188aedb8da5a39ec08"><td class="mdescLeft">&#160;</td><td class="mdescRight">A modified version of printf, specially designed to handle message content.  <br /></td></tr>
<tr class="separator:ga37a90a7c7b0c76188aedb8da5a39ec08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1ff11ca18271df5512699d276b6ba1e" id="r_gad1ff11ca18271df5512699d276b6ba1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad1ff11ca18271df5512699d276b6ba1e">EZTR_MsgSContent_PrintfLine</a> (const char *format,...)</td></tr>
<tr class="memdesc:gad1ff11ca18271df5512699d276b6ba1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A modified version of printf, specially designed to handle message content.  <br /></td></tr>
<tr class="separator:gad1ff11ca18271df5512699d276b6ba1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9672989bc812f2b03a238fe422e2f19" id="r_gaf9672989bc812f2b03a238fe422e2f19"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf9672989bc812f2b03a238fe422e2f19">EZTR_MsgSContent_Sprintf</a> (char *buffer, const char *format,...)</td></tr>
<tr class="memdesc:gaf9672989bc812f2b03a238fe422e2f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">A modified version of printf, specially designed to handle message content.  <br /></td></tr>
<tr class="separator:gaf9672989bc812f2b03a238fe422e2f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7c28d2307ddff188da8705b7b426ceb" id="r_gac7c28d2307ddff188da8705b7b426ceb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac7c28d2307ddff188da8705b7b426ceb">EZTR_MsgSContent_Snprintf</a> (char *buffer, size_t count, const char *format,...)</td></tr>
<tr class="memdesc:gac7c28d2307ddff188da8705b7b426ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A modified version of printf, specially designed to handle message content.  <br /></td></tr>
<tr class="separator:gac7c28d2307ddff188da8705b7b426ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d5300f9289c9d3ed0b64175aef3c8b8" id="r_ga8d5300f9289c9d3ed0b64175aef3c8b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8d5300f9289c9d3ed0b64175aef3c8b8">EZTR_MsgSContent_Vsnprintf</a> (char *buffer, size_t count, const char *format, va_list va)</td></tr>
<tr class="memdesc:ga8d5300f9289c9d3ed0b64175aef3c8b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A modified version of printf, specially designed to handle message content.  <br /></td></tr>
<tr class="separator:ga8d5300f9289c9d3ed0b64175aef3c8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9de78728bd6fb85269e97d135ec69180" id="r_ga9de78728bd6fb85269e97d135ec69180"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9de78728bd6fb85269e97d135ec69180">EZTR_MsgSContent_Vprintf</a> (const char *format, va_list va)</td></tr>
<tr class="memdesc:ga9de78728bd6fb85269e97d135ec69180"><td class="mdescLeft">&#160;</td><td class="mdescRight">A modified version of printf, specially designed to handle message content.  <br /></td></tr>
<tr class="separator:ga9de78728bd6fb85269e97d135ec69180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34be36f8427a9e5af06d8b3dabcf34c2" id="r_ga34be36f8427a9e5af06d8b3dabcf34c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga34be36f8427a9e5af06d8b3dabcf34c2">EZTR_MsgSContent_Fctprintf</a> (void(*out)(char character, void *arg), void *arg, const char *format,...)</td></tr>
<tr class="memdesc:ga34be36f8427a9e5af06d8b3dabcf34c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A modified version of printf, specially designed to handle message content.  <br /></td></tr>
<tr class="separator:ga34be36f8427a9e5af06d8b3dabcf34c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae288fd74c3f0df7ebafbbd4f795a68f6" name="gae288fd74c3f0df7ebafbbd4f795a68f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae288fd74c3f0df7ebafbbd4f795a68f6">&#9670;&#160;</a></span>EZTR_Basic_AddCustomBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_Basic_AddCustomBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="eztr__api_8h.html#af14c939010aeb8ff548788278b5e1b0f">EZTR_CustomMsgHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="eztr__api_8h.html#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare a brand new (i.e: custom) message by copying from a buffer defined by the user. </p>
<p>If you've defined a message using the MsgBuffer/MsgSContent functions, you can use this to set it (or, rather, a copy of it) as the new message.</p>
<p>To avoid potential ID conflicts between mods, the u16 textId for this message will be assigned by EZTR and will be accessable via the handle. See <code><a class="el" href="eztr__api_8h.html#af14c939010aeb8ff548788278b5e1b0f" title="The type declaration for custom message handle.">EZTR_CustomMsgHandle</a></code> for more information on how custom message handles work.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle for the new message. </td></tr>
    <tr><td class="paramname">buf</td><td>The message buffer to copy from. </td></tr>
    <tr><td class="paramname">callback</td><td>A function pointer to call right before this text is displayed. Useful for dynamic text. Set as NULL if you don't want to use a callback. See <code><a class="el" href="eztr__api_8h.html#ad9ba35ad8684a0265d641043caa81bc5" title="The function pointer type for message callbacks.">EZTR_MsgCallback</a></code> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaba5d26d7477edd4ba4ec2be15766e136" name="gaba5d26d7477edd4ba4ec2be15766e136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba5d26d7477edd4ba4ec2be15766e136">&#9670;&#160;</a></span>EZTR_Basic_AddCustomText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_Basic_AddCustomText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="eztr__api_8h.html#af14c939010aeb8ff548788278b5e1b0f">EZTR_CustomMsgHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>text_box_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>text_box_y_pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>display_icon</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>next_message_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>first_item_rupees</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>second_item_rupees</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>pipe_escape_bytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>content</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="eztr__api_8h.html#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare a brand new (i.e: custom) message by defining the header attributes and message content. </p>
<p>This is probably the easiest method to declare new messages.</p>
<p>To avoid potential ID conflicts between mods, the u16 textId for this message will be assigned by EZTR and will be accessable via the handle. See <code><a class="el" href="eztr__api_8h.html#af14c939010aeb8ff548788278b5e1b0f" title="The type declaration for custom message handle.">EZTR_CustomMsgHandle</a></code> for more information on how custom message handles work.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle for the new message. </td></tr>
    <tr><td class="paramname">text_box_type</td><td>The style of textbox to display. Use the <code><a class="el" href="eztr__api_8h.html#ac7a0819ee2ed5d0e939030ae98b9171c" title="Used in the message header to indicate the style of textbox used for the message.">EZTR_TextBoxType</a></code> enum for more readable values. </td></tr>
    <tr><td class="paramname">text_box_y_pos</td><td>The vertical position of the textbox on-screen. </td></tr>
    <tr><td class="paramname">display_icon</td><td>Displays an icon in the textbox. Use the <code><a class="el" href="eztr__api_8h.html#a716ef28fc50ca98601dddf9fb05240cb" title="Used in the message header to indicate a display icon for the message.">EZTR_TextBoxIcon</a></code> enum for more readable values. Use <code>EZTR_ICON_NO_ICON</code> for no icon. </td></tr>
    <tr><td class="paramname">next_message_id</td><td>The next message to display. If there is no next message, or the next message is determined by code, use 0xFFFF or <code>EZTR_NO_VALUE</code>. </td></tr>
    <tr><td class="paramname">first_item_rupees</td><td>The price of the first item being offered for sale, if one exists. If there is no item, use 0xFFFF or <code>EZTR_NO_VALUE</code>. </td></tr>
    <tr><td class="paramname">second_item_rupees</td><td>The price of the second item being offered for sale, if one exists. If there is no item, use 0xFFFF or <code>EZTR_NO_VALUE</code>. </td></tr>
    <tr><td class="paramname">pipe_escape_bytes</td><td>If true, <code>content</code> is passed through <code>EZTR_MsgBuffer_Sprintf("%m", content)</code>. If false, then <code>content</code> is copied directly into storage. </td></tr>
    <tr><td class="paramname">content</td><td>The new text content to display. If you want empty content (for use with dynamic messages), use "\xBF". </td></tr>
    <tr><td class="paramname">callback</td><td>A function pointer to call right before this text is displayed. Useful for dynamic messages. Set as NULL if you don't want to use a callback. See <code><a class="el" href="eztr__api_8h.html#ad9ba35ad8684a0265d641043caa81bc5" title="The function pointer type for message callbacks.">EZTR_MsgCallback</a></code> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaed8bd9e796160a2657adf03a77703baf" name="gaed8bd9e796160a2657adf03a77703baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed8bd9e796160a2657adf03a77703baf">&#9670;&#160;</a></span>EZTR_Basic_AddCustomTextEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_Basic_AddCustomTextEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="eztr__api_8h.html#af14c939010aeb8ff548788278b5e1b0f">EZTR_CustomMsgHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="eztr__api_8h.html#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare a brand new (i.e: custom) message, where the replacement message is empty. </p>
<p>This is primarily used if you want the message to be completely dynamically generated.</p>
<p>To avoid potential ID conflicts between mods, the u16 textId for this message will be assigned by EZTR and will be accessable via the handle. See <code><a class="el" href="eztr__api_8h.html#af14c939010aeb8ff548788278b5e1b0f" title="The type declaration for custom message handle.">EZTR_CustomMsgHandle</a></code> for more information on how custom message handles work.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle for the new message. </td></tr>
    <tr><td class="paramname">callback</td><td>A function pointer to call right before this text is displayed, in which you will construct the complete message buffer dynamically. See <code><a class="el" href="eztr__api_8h.html#ad9ba35ad8684a0265d641043caa81bc5" title="The function pointer type for message callbacks.">EZTR_MsgCallback</a></code> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8001f916103311b701e403d62f776074" name="ga8001f916103311b701e403d62f776074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8001f916103311b701e403d62f776074">&#9670;&#160;</a></span>EZTR_Basic_ReplaceBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_Basic_ReplaceBuffer </td>
          <td>(</td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>textId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="eztr__api_8h.html#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare a replacement of a vanilla message by copying from a buffer defined by the user. </p>
<p>If you've defined a message using the MsgBuffer/MsgSContent functions, you can use this to set it (or, rather, a copy of it) as a replacement for a vanilla message.</p>
<p>Note that this function is meant for replacing vanilla messages only. It will not allow you to use a textId greater than 0x354C, as that is the highest textId value found in the vanilla game. If you wish to create/modify a custom message, see <code><a class="el" href="#gae288fd74c3f0df7ebafbbd4f795a68f6" title="Declare a brand new (i.e: custom) message by copying from a buffer defined by the user.">EZTR_Basic_AddCustomBuffer()</a></code> and <a class="el" href="#ga52a12f735129bbe48bc0780c47fa7665" title="Declare a replacement for a custom message by copying from a buffer defined by the user.">EZTR_Basic_ReplaceCustomBuffer()</a>`</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textId</td><td>The id of the vanilla message you wish to replace. </td></tr>
    <tr><td class="paramname">buf</td><td>The message buffer to copy from. </td></tr>
    <tr><td class="paramname">callback</td><td>A function pointer to call right before this text is displayed. Useful for dynamic text. Set as NULL if you don't want to use a callback. See <code><a class="el" href="eztr__api_8h.html#ad9ba35ad8684a0265d641043caa81bc5" title="The function pointer type for message callbacks.">EZTR_MsgCallback</a></code> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga52a12f735129bbe48bc0780c47fa7665" name="ga52a12f735129bbe48bc0780c47fa7665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52a12f735129bbe48bc0780c47fa7665">&#9670;&#160;</a></span>EZTR_Basic_ReplaceCustomBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_Basic_ReplaceCustomBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="eztr__api_8h.html#af14c939010aeb8ff548788278b5e1b0f">EZTR_CustomMsgHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="eztr__api_8h.html#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare a replacement for a custom message by copying from a buffer defined by the user. </p>
<p>If you've defined a message using the MsgBuffer/MsgSContent functions, you can use this to set it (or, rather, a copy of it) as the new message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle for the message being replaced. </td></tr>
    <tr><td class="paramname">buf</td><td>The message buffer to copy from. </td></tr>
    <tr><td class="paramname">callback</td><td>A function pointer to call right before this text is displayed. Useful for dynamic text. Set as NULL if you don't want to use a callback. See <code><a class="el" href="eztr__api_8h.html#ad9ba35ad8684a0265d641043caa81bc5" title="The function pointer type for message callbacks.">EZTR_MsgCallback</a></code> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabc25b8ecceac76911ea9dfc91d94d9e8" name="gabc25b8ecceac76911ea9dfc91d94d9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc25b8ecceac76911ea9dfc91d94d9e8">&#9670;&#160;</a></span>EZTR_Basic_ReplaceCustomText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_Basic_ReplaceCustomText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="eztr__api_8h.html#af14c939010aeb8ff548788278b5e1b0f">EZTR_CustomMsgHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>text_box_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>text_box_y_pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>display_icon</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>next_message_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>first_item_rupees</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>second_item_rupees</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>pipe_escape_bytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>content</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="eztr__api_8h.html#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare a replacement of a custom message by defining the header attributes and message content. </p>
<p>This is probably the easiest method to replace custom messages, even those defined by other mods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle for the message being replaced. </td></tr>
    <tr><td class="paramname">text_box_type</td><td>The style of textbox to display. Use the <code><a class="el" href="eztr__api_8h.html#ac7a0819ee2ed5d0e939030ae98b9171c" title="Used in the message header to indicate the style of textbox used for the message.">EZTR_TextBoxType</a></code> enum for more readable values. </td></tr>
    <tr><td class="paramname">text_box_y_pos</td><td>The vertical position of the textbox on-screen. </td></tr>
    <tr><td class="paramname">display_icon</td><td>Displays an icon in the textbox. Use the <code><a class="el" href="eztr__api_8h.html#a716ef28fc50ca98601dddf9fb05240cb" title="Used in the message header to indicate a display icon for the message.">EZTR_TextBoxIcon</a></code> enum for more readable values. Use <code>EZTR_ICON_NO_ICON</code> for no icon. </td></tr>
    <tr><td class="paramname">next_message_id</td><td>The next message to display. If there is no next message, or the next message is determined by code, use 0xFFFF or <code>EZTR_NO_VALUE</code>. </td></tr>
    <tr><td class="paramname">first_item_rupees</td><td>The price of the first item being offered for sale, if one exists. If there is no item, use 0xFFFF or <code>EZTR_NO_VALUE</code>. </td></tr>
    <tr><td class="paramname">second_item_rupees</td><td>The price of the second item being offered for sale, if one exists. If there is no item, use 0xFFFF or <code>EZTR_NO_VALUE</code>. </td></tr>
    <tr><td class="paramname">pipe_escape_bytes</td><td>If true, <code>content</code> is passed through <code>EZTR_MsgBuffer_Sprintf("%m", content)</code>. If false, then <code>content</code> is copied directly into storage. </td></tr>
    <tr><td class="paramname">content</td><td>The new text content to display. If you want empty content (for use with dynamic messages), use "\xBF". </td></tr>
    <tr><td class="paramname">callback</td><td>A function pointer to call right before this text is displayed. Useful for dynamic messages. Set as NULL if you don't want to use a callback. See <code><a class="el" href="eztr__api_8h.html#ad9ba35ad8684a0265d641043caa81bc5" title="The function pointer type for message callbacks.">EZTR_MsgCallback</a></code> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga130700fec5bb6f9469a5c41847f2fbb6" name="ga130700fec5bb6f9469a5c41847f2fbb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga130700fec5bb6f9469a5c41847f2fbb6">&#9670;&#160;</a></span>EZTR_Basic_ReplaceText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_Basic_ReplaceText </td>
          <td>(</td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>textId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>text_box_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>text_box_y_pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>display_icon</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>next_message_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>first_item_rupees</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>second_item_rupees</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>pipe_escape_bytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>content</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="eztr__api_8h.html#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare a replacement of a vanilla message by defining the header attributes and message content. </p>
<p>This is probably the easiest method to declare replacement text.</p>
<p>Note that this function is meant for replacing vanilla messages only. It will not allow you to use a textId greater than 0x354C, as that is the highest textId value found in the vanilla game. If you wish to create/modify a custom message, see <code><a class="el" href="#gaba5d26d7477edd4ba4ec2be15766e136" title="Declare a brand new (i.e: custom) message by defining the header attributes and message content.">EZTR_Basic_AddCustomText()</a></code> and <a class="el" href="#gabc25b8ecceac76911ea9dfc91d94d9e8" title="Declare a replacement of a custom message by defining the header attributes and message content.">EZTR_Basic_ReplaceCustomText()</a>`</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textId</td><td>The id of the vanilla message you wish to replace. </td></tr>
    <tr><td class="paramname">text_box_type</td><td>The style of textbox to display. Use the <code><a class="el" href="eztr__api_8h.html#ac7a0819ee2ed5d0e939030ae98b9171c" title="Used in the message header to indicate the style of textbox used for the message.">EZTR_TextBoxType</a></code> enum for more readable values. </td></tr>
    <tr><td class="paramname">text_box_y_pos</td><td>The vertical position of the textbox on-screen. </td></tr>
    <tr><td class="paramname">display_icon</td><td>Displays an icon in the textbox. Use the <code><a class="el" href="eztr__api_8h.html#a716ef28fc50ca98601dddf9fb05240cb" title="Used in the message header to indicate a display icon for the message.">EZTR_TextBoxIcon</a></code> enum for more readable values. Use <code>EZTR_ICON_NO_ICON</code> for no icon. </td></tr>
    <tr><td class="paramname">next_message_id</td><td>The next message to display. If there is no next message, or the next message is determined by code, use 0xFFFF or <code>EZTR_NO_VALUE</code>. </td></tr>
    <tr><td class="paramname">first_item_rupees</td><td>The price of the first item being offered for sale, if one exists. If there is no item, use 0xFFFF or <code>EZTR_NO_VALUE</code>. </td></tr>
    <tr><td class="paramname">second_item_rupees</td><td>The price of the second item being offered for sale, if one exists. If there is no item, use 0xFFFF or <code>EZTR_NO_VALUE</code>. </td></tr>
    <tr><td class="paramname">pipe_escape_bytes</td><td>If true, <code>content</code> is passed through <code>EZTR_MsgBuffer_Sprintf("%m", content)</code>. If false, then <code>content</code> is copied directly into storage. </td></tr>
    <tr><td class="paramname">content</td><td>The new text content to display. If you want empty content (for use with dynamic messages), use "\xBF". </td></tr>
    <tr><td class="paramname">callback</td><td>A function pointer to call right before this text is displayed. Useful for dynamic messages. Set as NULL if you don't want to use a callback. See <code><a class="el" href="eztr__api_8h.html#ad9ba35ad8684a0265d641043caa81bc5" title="The function pointer type for message callbacks.">EZTR_MsgCallback</a></code> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2c3d2fef5e69105140806673fce4d985" name="ga2c3d2fef5e69105140806673fce4d985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c3d2fef5e69105140806673fce4d985">&#9670;&#160;</a></span>EZTR_Basic_ReplaceTextEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_Basic_ReplaceTextEmpty </td>
          <td>(</td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>textId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="eztr__api_8h.html#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare a replacement of a vanilla message, where the replacement message is empty. </p>
<p>This is primarily used if you want the message to be completely dynamically generated.</p>
<p>Note that this function is meant for replacing vanilla messages only. It will not allow you to use a textId greater than 0x354C, as that is the highest textId value found in the vanilla game. If you wish to create/modify a custom message, see <code><a class="el" href="#gaed8bd9e796160a2657adf03a77703baf" title="Declare a brand new (i.e: custom) message, where the replacement message is empty.">EZTR_Basic_AddCustomTextEmpty()</a></code> and <a class="el" href="eztr__api_8h.html#ac21eaf9a0b5b451ff82363418ce9eb10" title="Declare a replacement of a custom message, where the replacement message is empty.">EZTR_Basic_ReplaceCustomTextEmpty()</a>`</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textId</td><td>The id of the vanilla message you wish to replace. </td></tr>
    <tr><td class="paramname">callback</td><td>A function pointer to call right before this text is displayed, in which you will construct the complete message buffer dynamically. See <code><a class="el" href="eztr__api_8h.html#ad9ba35ad8684a0265d641043caa81bc5" title="The function pointer type for message callbacks.">EZTR_MsgCallback</a></code> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4370a73be9636af6f60dfb954342cedc" name="ga4370a73be9636af6f60dfb954342cedc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4370a73be9636af6f60dfb954342cedc">&#9670;&#160;</a></span>EZTR_MsgBuffer_ContentLen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 EZTR_MsgBuffer_ContentLen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of the message buffer's content region, in bytes. </p>
<p>Effectively <code>EZTR_MsgBuffer_Len(buf) - 11</code> or <code>EZTR_MsgSContent_Len(buf-&gt;partition.content)</code>. Does not include the termination character '\xBF'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to measure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u32 The number of bytes the message buffer's content takes up. </dd></dl>

</div>
</div>
<a id="ga020cddc8868430e6afd77733907d6139" name="ga020cddc8868430e6afd77733907d6139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga020cddc8868430e6afd77733907d6139">&#9670;&#160;</a></span>EZTR_MsgBuffer_Copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 EZTR_MsgBuffer_Copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from <code>src</code> into the message buffer <code>dst</code>. </p>
<p>Unlike something like <code>strcoy()</code>, this method is safe as long as dst is a full-sized message buffer, as it will not copy beyond the message buffer size.</p>
<p>Because <code>src</code> is expected to have a header region, the message termination characters '\xBF' are ignored for the first 11 bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The message buffer to copy into. </td></tr>
    <tr><td class="paramname">src</td><td>The data to copy. If you want to copy from another message buffer, use <code>src-&gt;raw.schar</code> or typecast src as <code>char*</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u32 The number of bytes copied. </dd></dl>

</div>
</div>
<a id="ga39c2beef126a75f0222b69759008120e" name="ga39c2beef126a75f0222b69759008120e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39c2beef126a75f0222b69759008120e">&#9670;&#160;</a></span>EZTR_MsgBuffer_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> * EZTR_MsgBuffer_Create </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new message buffer object on the heap. </p>
<p>The created buffer will be have a default header and an empty content region. You need to free any buffer you create using this function with <code><a class="el" href="#ga27b268a005666834e39511fd0dc2c469" title="Frees/destroys a message buffer.">EZTR_MsgBuffer_Destroy()</a></code>, or else you will create a memory leak.</p>
<dl class="section return"><dt>Returns</dt><dd>MsgBuffer* A pointer to the buffer you created. </dd></dl>

</div>
</div>
<a id="ga09fc35479c7e6fee9e6049f473363177" name="ga09fc35479c7e6fee9e6049f473363177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09fc35479c7e6fee9e6049f473363177">&#9670;&#160;</a></span>EZTR_MsgBuffer_CreateFromStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> * EZTR_MsgBuffer_CreateFromStr </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new message buffer object on the heap, and copies <code>src</code> into it. </p>
<p>Equivalent to <code>buf = <a class="el" href="#ga39c2beef126a75f0222b69759008120e" title="Creates a new message buffer object on the heap.">EZTR_MsgBuffer_Create()</a>; EZTR_MsgBuffer_Copy(buf);</code></p>
<p>You need to free any buffer you create using this function with <code><a class="el" href="#ga27b268a005666834e39511fd0dc2c469" title="Frees/destroys a message buffer.">EZTR_MsgBuffer_Destroy()</a></code>, or else you will create a memory leak.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The content to copy into the buffer. Expected to have a header region, and be terminated with '\xBF'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MsgBuffer* A pointer to the buffer you created. </dd></dl>

</div>
</div>
<a id="ga91896add7333589c5d04730e84c8f6f4" name="ga91896add7333589c5d04730e84c8f6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91896add7333589c5d04730e84c8f6f4">&#9670;&#160;</a></span>EZTR_MsgBuffer_CreateFromStrN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> * EZTR_MsgBuffer_CreateFromStrN </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new message buffer object on the heap, and copies <code>src</code> into it for up to <code>len</code> bytes. </p>
<p>Equivalent to <code>buf = <a class="el" href="#ga39c2beef126a75f0222b69759008120e" title="Creates a new message buffer object on the heap.">EZTR_MsgBuffer_Create()</a>; EZTR_MsgBuffer_CopyN(buf, len);</code></p>
<p>You need to free any buffer you create using this function with <code><a class="el" href="#ga27b268a005666834e39511fd0dc2c469" title="Frees/destroys a message buffer.">EZTR_MsgBuffer_Destroy()</a></code>, or else you will create a memory leak.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The content to copy into the buffer. Expected to have a header region, and be terminated with '\xBF'. </td></tr>
    <tr><td class="paramname">len</td><td>The maximum number of bytes to copy. If a '\xBF<code>is encountered in the content region of</code>src<code>, the function will stop copying before</code>len` is reached. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MsgBuffer* A pointer to the buffer you created. </dd></dl>

</div>
</div>
<a id="ga27b268a005666834e39511fd0dc2c469" name="ga27b268a005666834e39511fd0dc2c469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27b268a005666834e39511fd0dc2c469">&#9670;&#160;</a></span>EZTR_MsgBuffer_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_MsgBuffer_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees/destroys a message buffer. </p>
<p>EZTR only expects you to destroy buffers that you create youself using one of the above functions.A_BTN_STATE_IDLE Buffers given to you by in <code>MsgCallback</code> functions are created and destroyed by EZTR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>A pointer to the message buffer to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga21eec47bd44a5a81b37aa88561d17146" name="ga21eec47bd44a5a81b37aa88561d17146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21eec47bd44a5a81b37aa88561d17146">&#9670;&#160;</a></span>EZTR_MsgBuffer_GetContentPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * EZTR_MsgBuffer_GetContentPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a pointer to the beginning of the content region for a desired message buffer. </p>
<p>Equivalent to <code>buf-&gt;partition.content</code>, or <code>buf-&gt;data.content</code> assuming EZTR_MsgBufferData is being packed correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to get the the content from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char* The beginning of the message buffer's content region. </dd></dl>

</div>
</div>
<a id="gaecbd0e2114b2169dac0254e15bb920f4" name="gaecbd0e2114b2169dac0254e15bb920f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecbd0e2114b2169dac0254e15bb920f4">&#9670;&#160;</a></span>EZTR_MsgBuffer_GetFirstItemRupees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 EZTR_MsgBuffer_GetFirstItemRupees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the first_item_rupees from a message buffer's header. </p>
<p>Useful if your compiler is having trouble with the <code>__attribute_((packed))</code> on <code>EZTR_MsgBufferData</code>, and the data isn't lining up correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u16 The first_item_rupees of the message buffer. If <code>EZTR_MsgBufferData</code> is being packed correctly, this will be equivalent to <code>buf-&gt;data.first_item_rupees</code>. </dd></dl>

</div>
</div>
<a id="ga015f838b68601c44d38be12780cb0834" name="ga015f838b68601c44d38be12780cb0834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga015f838b68601c44d38be12780cb0834">&#9670;&#160;</a></span>EZTR_MsgBuffer_GetNextMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 EZTR_MsgBuffer_GetNextMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the next_message_id from a message buffer's header. </p>
<p>Useful if your compiler is having trouble with the <code>__attribute_((packed))</code> on <code>EZTR_MsgBufferData</code>, and the data isn't lining up correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u16 The display_icon of the message buffer. If <code>EZTR_MsgBufferData</code> is being packed correctly, this will be equivalent to <code>buf-&gt;data.next_message_id</code>. </dd></dl>

</div>
</div>
<a id="gaa2894fa932a1b5ab0429b26395eca921" name="gaa2894fa932a1b5ab0429b26395eca921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2894fa932a1b5ab0429b26395eca921">&#9670;&#160;</a></span>EZTR_MsgBuffer_GetSecondItemRupees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 EZTR_MsgBuffer_GetSecondItemRupees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the second_item_rupees from a message buffer's header. </p>
<p>Useful if your compiler is having trouble with the <code>__attribute_((packed))</code> on <code>EZTR_MsgBufferData</code>, and the data isn't lining up correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u16 The second_item_rupees of the message buffer. If <code>EZTR_MsgBufferData</code> is being packed correctly, this will be equivalent to <code>buf-&gt;data.second_item_rupees</code>. </dd></dl>

</div>
</div>
<a id="ga4bc50f85b99782d5aa97f8d122d1587d" name="ga4bc50f85b99782d5aa97f8d122d1587d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bc50f85b99782d5aa97f8d122d1587d">&#9670;&#160;</a></span>EZTR_MsgBuffer_GetTextBoxDisplayIcon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 EZTR_MsgBuffer_GetTextBoxDisplayIcon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the display_icon from a message buffer's header. </p>
<p>Useful if your compiler is having trouble with the <code>__attribute_((packed))</code> on <code>EZTR_MsgBufferData</code>, and the data isn't lining up correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u8 The display_icon of the message buffer. If <code>EZTR_MsgBufferData</code> is being packed correctly, this will be equivalent to <code>buf-&gt;data.display_icon</code>. </dd></dl>

</div>
</div>
<a id="ga6fa740d70e876eb91c758c0686f06cb6" name="ga6fa740d70e876eb91c758c0686f06cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fa740d70e876eb91c758c0686f06cb6">&#9670;&#160;</a></span>EZTR_MsgBuffer_GetTextBoxType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 EZTR_MsgBuffer_GetTextBoxType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the text_box_type from a message buffer's header. </p>
<p>Useful if your compiler is having trouble with the <code>__attribute_((packed))</code> on <code>EZTR_MsgBufferData</code>, and the data isn't lining up correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u8 The text_box_type of the message buffer. If <code>EZTR_MsgBufferData</code> is being packed correctly, this will be equivalent to <code>buf-&gt;data.text_box_type</code>. </dd></dl>

</div>
</div>
<a id="gacb5e6b7691b750e998d5258cd180ef8e" name="gacb5e6b7691b750e998d5258cd180ef8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb5e6b7691b750e998d5258cd180ef8e">&#9670;&#160;</a></span>EZTR_MsgBuffer_GetTextBoxYPos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 EZTR_MsgBuffer_GetTextBoxYPos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the text_box_y_pos from a message buffer's header. </p>
<p>Useful if your compiler is having trouble with the <code>__attribute_((packed))</code> on <code>EZTR_MsgBufferData</code>, and the data isn't lining up correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u8 The text_box_y_pos of the message buffer. If <code>EZTR_MsgBufferData</code> is being packed correctly, this will be equivalent to <code>buf-&gt;data.text_box_y_pos</code>. </dd></dl>

</div>
</div>
<a id="ga8b931bdaf93270ddc7ed445cf699b1fe" name="ga8b931bdaf93270ddc7ed445cf699b1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b931bdaf93270ddc7ed445cf699b1fe">&#9670;&#160;</a></span>EZTR_MsgBuffer_Len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 EZTR_MsgBuffer_Len </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of the message buffer's stored data, in bytes. </p>
<p>Does not include the termination character '\xBF'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to measure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u32 The number of bytes the message buffer's data takes up. </dd></dl>

</div>
</div>
<a id="gaa46abdcae0cc0572a9b3d6474f01bc62" name="gaa46abdcae0cc0572a9b3d6474f01bc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa46abdcae0cc0572a9b3d6474f01bc62">&#9670;&#160;</a></span>EZTR_MsgBuffer_NCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 EZTR_MsgBuffer_NCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from <code>src</code> into the message buffer <code>dst</code>, up to <code>len</code> bytes. </p>
<p>Because <code>src</code> is expected to have a header region, the message termination characters '\xBF' are ignored for the first 11 bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The message buffer to copy into. </td></tr>
    <tr><td class="paramname">src</td><td>The data to copy. If you want to copy from another message buffer, use <code>src-&gt;raw.schar</code> or typecast src as <code>char*</code>. </td></tr>
    <tr><td class="paramname">len</td><td>The maximum number of bytes to copy. If a '\xBF<code>is encountered in the content region of</code>src<code>, the function will stop copying before</code>len` is reached. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u32 The number of bytes copied. </dd></dl>

</div>
</div>
<a id="gaf8d9e959cd5fa20e5bdadb8cce347c22" name="gaf8d9e959cd5fa20e5bdadb8cce347c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8d9e959cd5fa20e5bdadb8cce347c22">&#9670;&#160;</a></span>EZTR_MsgBuffer_Print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_MsgBuffer_Print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the contents of a message buffer to the console. </p>
<p>Each value in the header will be labeled. The content region will stop printing after the '\xBF' termination character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga59379a5596f63ec6c0bcd7eb4fb7fd14" name="ga59379a5596f63ec6c0bcd7eb4fb7fd14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59379a5596f63ec6c0bcd7eb4fb7fd14">&#9670;&#160;</a></span>EZTR_MsgBuffer_PrintFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_MsgBuffer_PrintFull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the contents of a message buffer to the console. </p>
<p>Each value in the header will be labeled. The this function prints the entire 1279 bytes of the content region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga89663200d1aa9ffe42c27039bb2701d4" name="ga89663200d1aa9ffe42c27039bb2701d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89663200d1aa9ffe42c27039bb2701d4">&#9670;&#160;</a></span>EZTR_MsgBuffer_SetFirstItemRupees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_MsgBuffer_SetFirstItemRupees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the first_item_rupees of the message buffer's header. </p>
<p>Useful if your compiler is having trouble with the <code>__attribute_((packed))</code> on <code>EZTR_MsgBufferData</code>, and the data isn't lining up correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to write to. </td></tr>
    <tr><td class="paramname">value</td><td>The new first_item_rupees value. If <code>EZTR_MsgBufferData</code> is being packed correctly, this will be equivalent to <code>buf-&gt;data.first_item_rupees = icon</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga46f857fd4054f0b076012a85b8b14f08" name="ga46f857fd4054f0b076012a85b8b14f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46f857fd4054f0b076012a85b8b14f08">&#9670;&#160;</a></span>EZTR_MsgBuffer_SetNextMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_MsgBuffer_SetNextMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>textId</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the next_message_id of the message buffer's header. </p>
<p>Useful if your compiler is having trouble with the <code>__attribute_((packed))</code> on <code>EZTR_MsgBufferData</code>, and the data isn't lining up correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to write to. </td></tr>
    <tr><td class="paramname">textId</td><td>The new display_icon value. If <code>EZTR_MsgBufferData</code> is being packed correctly, this will be equivalent to <code>buf-&gt;data.next_message_id = icon</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga873aabed87f63550b8818174e16f7f63" name="ga873aabed87f63550b8818174e16f7f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga873aabed87f63550b8818174e16f7f63">&#9670;&#160;</a></span>EZTR_MsgBuffer_SetSecondItemRupees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_MsgBuffer_SetSecondItemRupees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the second_item_rupees of the message buffer's header. </p>
<p>Useful if your compiler is having trouble with the <code>__attribute_((packed))</code> on <code>EZTR_MsgBufferData</code>, and the data isn't lining up correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to write to. </td></tr>
    <tr><td class="paramname">value</td><td>The new second_item_rupees value. If <code>EZTR_MsgBufferData</code> is being packed correctly, this will be equivalent to <code>buf-&gt;data.second_item_rupees = icon</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacf6d8ba4bde04faab7330540c4d284cd" name="gacf6d8ba4bde04faab7330540c4d284cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf6d8ba4bde04faab7330540c4d284cd">&#9670;&#160;</a></span>EZTR_MsgBuffer_SetTextBoxDisplayIcon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_MsgBuffer_SetTextBoxDisplayIcon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>icon</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the display_icon of the message buffer's header. </p>
<p>Useful if your compiler is having trouble with the <code>__attribute_((packed))</code> on <code>EZTR_MsgBufferData</code>, and the data isn't lining up correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to write to. </td></tr>
    <tr><td class="paramname">icon</td><td>The new display_icon value. If <code>EZTR_MsgBufferData</code> is being packed correctly, this will be equivalent to <code>buf-&gt;data.display_icon = icon</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga530d275045043f28d94b762b36daf66e" name="ga530d275045043f28d94b762b36daf66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga530d275045043f28d94b762b36daf66e">&#9670;&#160;</a></span>EZTR_MsgBuffer_SetTextBoxType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_MsgBuffer_SetTextBoxType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the text_box_type of the message buffer's header. </p>
<p>Useful if your compiler is having trouble with the <code>__attribute_((packed))</code> on <code>EZTR_MsgBufferData</code>, and the data isn't lining up correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to write to. </td></tr>
    <tr><td class="paramname">type</td><td>The new text_box_type value. If <code>EZTR_MsgBufferData</code> is being packed correctly, this will be equivalent to <code>buf-&gt;data.text_box_type = type</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabaf1d5e1b0fc9637427f0c758bff0da9" name="gabaf1d5e1b0fc9637427f0c758bff0da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaf1d5e1b0fc9637427f0c758bff0da9">&#9670;&#160;</a></span>EZTR_MsgBuffer_SetTextBoxYPos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_MsgBuffer_SetTextBoxYPos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the text_box_y_pos of the message buffer's header. </p>
<p>Useful if your compiler is having trouble with the <code>__attribute_((packed))</code> on <code>EZTR_MsgBufferData</code>, and the data isn't lining up correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to write to. </td></tr>
    <tr><td class="paramname">pos</td><td>The new text_box_y_pos value. If <code>EZTR_MsgBufferData</code> is being packed correctly, this will be equivalent to <code>buf-&gt;data.text_box_y_pos = pos</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad149fb2e9d2c8fa3e0034ac54a61a678" name="gad149fb2e9d2c8fa3e0034ac54a61a678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad149fb2e9d2c8fa3e0034ac54a61a678">&#9670;&#160;</a></span>EZTR_MsgBuffer_WriteDefaultHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_MsgBuffer_WriteDefaultHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a message buffer's header to default values. </p>
<p>The default values for a message buffer header are:</p>
<ul>
<li>text_box_type = EZTR_STANDARD_TEXT_BOX_I (0)</li>
<li>text_box_y_pos = 0</li>
<li>display_icon = EZTR_ICON_NO_ICON (0xFE)</li>
<li>next_message_id = EZTR_NO_VALUE (0xFFFF)</li>
<li>first_item_rupees = EZTR_NO_VALUE (0xFFFF)</li>
<li>second_item_rupees = EZTR_NO_VALUE (0xFFFF)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the message buffer to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga578d94107d666a42c08bb3ad73fd8f33" name="ga578d94107d666a42c08bb3ad73fd8f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga578d94107d666a42c08bb3ad73fd8f33">&#9670;&#160;</a></span>EZTR_MsgBuffer_WriteHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_MsgBuffer_WriteHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>text_box_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>text_box_y_pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>display_icon</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>next_message_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>first_item_rupees</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>second_item_rupees</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the message buffer to write to. </td></tr>
    <tr><td class="paramname">text_box_type</td><td>The style of textbox to display. Use the <code><a class="el" href="eztr__api_8h.html#ac7a0819ee2ed5d0e939030ae98b9171c" title="Used in the message header to indicate the style of textbox used for the message.">EZTR_TextBoxType</a></code> enum for more readable values. </td></tr>
    <tr><td class="paramname">text_box_y_pos</td><td>The vertical position of the textbox on-screen. </td></tr>
    <tr><td class="paramname">display_icon</td><td>Displays an icon in the textbox. Use the <code><a class="el" href="eztr__api_8h.html#a716ef28fc50ca98601dddf9fb05240cb" title="Used in the message header to indicate a display icon for the message.">EZTR_TextBoxIcon</a></code> enum for more readable values. Use <code>EZTR_ICON_NO_ICON</code> for no icon. </td></tr>
    <tr><td class="paramname">next_message_id</td><td>The next message to display. If there is no next message, or the next message is determined by code, use 0xFFFF or <code>EZTR_NO_VALUE</code>. </td></tr>
    <tr><td class="paramname">first_item_rupees</td><td>The price of the first item being offered for sale, if one exists. If there is no item, use 0xFFFF or <code>EZTR_NO_VALUE</code>. </td></tr>
    <tr><td class="paramname">second_item_rupees</td><td>The price of the second item being offered for sale, if one exists. If there is no item, use 0xFFFF or <code>EZTR_NO_VALUE</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga72647d2cb1cbb660f9cb86df6074241f" name="ga72647d2cb1cbb660f9cb86df6074241f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72647d2cb1cbb660f9cb86df6074241f">&#9670;&#160;</a></span>EZTR_MsgSContent_Cat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * EZTR_MsgSContent_Cat </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the message content of <code>src</code> onto the end of <code>dst</code>. </p>
<p>Similar to <code>strcat()</code> for null-terminated strings.</p>
<p>This function is safe as long as <code>dst</code> points to the beginning of a message buffer's content region, as it will not produce message content larger than a message buffer's content region. Copying will stop once the maximum size is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The location to append message content into. </td></tr>
    <tr><td class="paramname">src</td><td>The message content to copy. Should be '\xBF' terminated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char* The pointer to the new string (i.e: to <code>dst</code>). </dd></dl>

</div>
</div>
<a id="gaedf2e411789c0ad0061471c74ba87204" name="gaedf2e411789c0ad0061471c74ba87204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedf2e411789c0ad0061471c74ba87204">&#9670;&#160;</a></span>EZTR_MsgSContent_Cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 EZTR_MsgSContent_Cmp </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two message content strings. </p>
<p>This function is safe as long as both <code>str1</code> and <code>str2</code> point to the content region of message buffers, as the comparison will not continue beyond that size.</p>
<p>Similar to <code>strcmp()</code> for null-terminated strings, but with one notable difference: With <code>strncmp()</code>, if two strings are equal for the first <code>n</code> characters, but one string continues after <code>n</code> while <br  />
 the other doesn't, the shorter string is considered 'lesser' because the null terminator &lsquo;&rsquo;\x00'<code>is naturally the lowest possible ASCII value. Because strings in MM are</code>'\XBF'` terminated, that behavior won't apply here.</p>
<p>In <code><a class="el" href="#gaedf2e411789c0ad0061471c74ba87204" title="Compares two message content strings.">EZTR_MsgSContent_Cmp()</a></code>, a special case is applied: If two strings are equal for <code>n</code> characters, but the next character after <code>n</code> is &lsquo;&rsquo;\XBF'` in one of the strings, it is considered the lesser string regardless of what the other character is.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>The first message content string to compare. </td></tr>
    <tr><td class="paramname">str2</td><td>The second message content string to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>s32 Returns 0 is the strings are the same, 1 if the first string is greater than the second, and -1 if the second string is greater than the first. </dd></dl>

</div>
</div>
<a id="ga663aa64051a106585368bd080dbfac91" name="ga663aa64051a106585368bd080dbfac91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga663aa64051a106585368bd080dbfac91">&#9670;&#160;</a></span>EZTR_MsgSContent_Copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 EZTR_MsgSContent_Copy </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies message content from <code>src</code> into the <code>dst</code>. </p>
<p>Similar to <code>strcpy()</code> for null-terminated strings.</p>
<p>This function is safe as long as <code>dst</code> points to the beginning of a message buffer's content region, since it will not copy bytes beyond that size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The location to copy message content into. </td></tr>
    <tr><td class="paramname">src</td><td>The message content to copy. Should be '\xBF' terminated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u32 The number of bytes copied. </dd></dl>

</div>
</div>
<a id="ga34be36f8427a9e5af06d8b3dabcf34c2" name="ga34be36f8427a9e5af06d8b3dabcf34c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34be36f8427a9e5af06d8b3dabcf34c2">&#9670;&#160;</a></span>EZTR_MsgSContent_Fctprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EZTR_MsgSContent_Fctprintf </td>
          <td>(</td>
          <td class="paramtype">void(*</td>          <td class="paramname"><span class="paramname"><em>out&#160;</em></span>)(char character, void *arg), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A modified version of printf, specially designed to handle message content. </p>
<p>see <a class="el" href="prinf_functions.html">EZTR Printf Functions</a> for more information on EZTR's custom printf behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
    <tr><td class="paramname">arg</td><td></td></tr>
    <tr><td class="paramname">format</td><td></td></tr>
    <tr><td class="paramname">...</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="gaffede5c9bbcd94fcedf72680c6ac3666" name="gaffede5c9bbcd94fcedf72680c6ac3666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffede5c9bbcd94fcedf72680c6ac3666">&#9670;&#160;</a></span>EZTR_MsgSContent_Len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 EZTR_MsgSContent_Len </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cont</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the length of the a message content string in bytes, not counting the '\xBF' termination character. </p>
<p>Similar to <code>strlen()</code> for null-terminated strings.</p>
<p>This function is safe as long as <code>cont</code> points to the beginning of a message buffer's content region, since it will not count bytes beyond that size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>The message content you want to get the length of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u32 The length of the message content, in bytes. </dd></dl>

</div>
</div>
<a id="gaa144e4595b017537667babed825e67eb" name="gaa144e4595b017537667babed825e67eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa144e4595b017537667babed825e67eb">&#9670;&#160;</a></span>EZTR_MsgSContent_NCat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * EZTR_MsgSContent_NCat </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the message content of <code>src</code> onto the end of <code>dst</code>, up to <code>len</code> bytes from <code>src</code>. </p>
<p>Similar to <code>strncat()</code> for null-terminated strings.</p>
<p>This function will not produce message content larger than a message buffer's content region. Copying will stop once the maximum size is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The location to append message content into. </td></tr>
    <tr><td class="paramname">src</td><td>The message content to copy. </td></tr>
    <tr><td class="paramname">len</td><td>The maximum number of bytes to copy. If a '\xBF' is encountered in <code>src</code>, the function will stop copying before <code>len</code> is reached. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char* The pointer to the new string (i.e: to <code>dst</code>). </dd></dl>

</div>
</div>
<a id="ga79545ea629e4fb127ad978a8518c310f" name="ga79545ea629e4fb127ad978a8518c310f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79545ea629e4fb127ad978a8518c310f">&#9670;&#160;</a></span>EZTR_MsgSContent_NCmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 EZTR_MsgSContent_NCmp </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares up to <code>len</code> bytes of two message content strings. </p>
<p>Similar to <code>strncmp()</code> for null-terminated strings, but with one notable difference: With <code>strncmp()</code>, if two strings are equal for the first <code>n</code> characters, but one string continues after <code>n</code> while <br  />
 the other doesn't, the shorter string is considered 'lesser' because the null terminator &lsquo;&rsquo;\x00'<code>is naturally the lowest possible ASCII value. Because strings in MM are</code>'\XBF'` terminated, that behavior won't apply here.</p>
<p>In <code><a class="el" href="#ga79545ea629e4fb127ad978a8518c310f" title="Compares up to len bytes of two message content strings.">EZTR_MsgSContent_NCmp()</a></code>, a special case is applied: If two strings are equal for <code>n</code> characters, but the next character after <code>n</code> is &lsquo;&rsquo;\XBF'` in one of the strings, it is considered the lesser string regardless of what the other character is.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>The first message content string to compare. </td></tr>
    <tr><td class="paramname">str2</td><td>The second message content string to compare. </td></tr>
    <tr><td class="paramname">len</td><td>The maximum number of bytes to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>s32 Returns 0 is the strings are the same, 1 if the first string is greater than the second, and -1 if the second string is greater than the first. </dd></dl>

</div>
</div>
<a id="ga942c2f98af6fe2a81428bdcfd8336183" name="ga942c2f98af6fe2a81428bdcfd8336183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga942c2f98af6fe2a81428bdcfd8336183">&#9670;&#160;</a></span>EZTR_MsgSContent_NCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 EZTR_MsgSContent_NCopy </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies message content from <code>src</code> into the <code>dst</code>, up to <code>len</code> bytes. </p>
<p>Similar to <code>strncpy()</code> for null-terminated strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The location to copy message content into. </td></tr>
    <tr><td class="paramname">src</td><td>The message content to copy. </td></tr>
    <tr><td class="paramname">len</td><td>The maximum number of bytes to copy. If a '\xBF' is encountered in <code>src</code>, the function will stop copying before <code>len</code> is reached. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u32 The number of bytes copied. </dd></dl>

</div>
</div>
<a id="ga37a90a7c7b0c76188aedb8da5a39ec08" name="ga37a90a7c7b0c76188aedb8da5a39ec08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37a90a7c7b0c76188aedb8da5a39ec08">&#9670;&#160;</a></span>EZTR_MsgSContent_Printf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EZTR_MsgSContent_Printf </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A modified version of printf, specially designed to handle message content. </p>
<p>see <a class="el" href="prinf_functions.html">EZTR Printf Functions</a> for more information on EZTR's custom printf behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td></td></tr>
    <tr><td class="paramname">...</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="gad1ff11ca18271df5512699d276b6ba1e" name="gad1ff11ca18271df5512699d276b6ba1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1ff11ca18271df5512699d276b6ba1e">&#9670;&#160;</a></span>EZTR_MsgSContent_PrintfLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EZTR_MsgSContent_PrintfLine </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A modified version of printf, specially designed to handle message content. </p>
<p>see <a class="el" href="prinf_functions.html">EZTR Printf Functions</a> for more information on EZTR's custom printf behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td></td></tr>
    <tr><td class="paramname">...</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="ga9cdf97a6b5c9d99e1154d1709e6f2dc4" name="ga9cdf97a6b5c9d99e1154d1709e6f2dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cdf97a6b5c9d99e1154d1709e6f2dc4">&#9670;&#160;</a></span>EZTR_MsgSContent_SetEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_MsgSContent_SetEmpty </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cont</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the message message content as empty.A_BTN_STATE_IDLE. </p>
<p>This is accomplished by setting the first character in the message content to the '\xBF' termination character. No other bytes are effected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>A pointer to message content string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac7c28d2307ddff188da8705b7b426ceb" name="gac7c28d2307ddff188da8705b7b426ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7c28d2307ddff188da8705b7b426ceb">&#9670;&#160;</a></span>EZTR_MsgSContent_Snprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EZTR_MsgSContent_Snprintf </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A modified version of printf, specially designed to handle message content. </p>
<p>see <a class="el" href="prinf_functions.html">EZTR Printf Functions</a> for more information on EZTR's custom printf behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td></td></tr>
    <tr><td class="paramname">count</td><td></td></tr>
    <tr><td class="paramname">format</td><td></td></tr>
    <tr><td class="paramname">...</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="gaf9672989bc812f2b03a238fe422e2f19" name="gaf9672989bc812f2b03a238fe422e2f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9672989bc812f2b03a238fe422e2f19">&#9670;&#160;</a></span>EZTR_MsgSContent_Sprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EZTR_MsgSContent_Sprintf </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A modified version of printf, specially designed to handle message content. </p>
<p>Unlike <code><a class="el" href="#ga37a90a7c7b0c76188aedb8da5a39ec08" title="A modified version of printf, specially designed to handle message content.">EZTR_MsgSContent_Printf()</a></code>, this function will append a newline to the end of console output.</p>
<p>see <a class="el" href="prinf_functions.html">EZTR Printf Functions</a> for more information on EZTR's custom printf behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td></td></tr>
    <tr><td class="paramname">format</td><td></td></tr>
    <tr><td class="paramname">...</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="ga9de78728bd6fb85269e97d135ec69180" name="ga9de78728bd6fb85269e97d135ec69180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9de78728bd6fb85269e97d135ec69180">&#9670;&#160;</a></span>EZTR_MsgSContent_Vprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EZTR_MsgSContent_Vprintf </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list</td>          <td class="paramname"><span class="paramname"><em>va</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A modified version of printf, specially designed to handle message content. </p>
<p>see <a class="el" href="prinf_functions.html">EZTR Printf Functions</a> for more information on EZTR's custom printf behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td></td></tr>
    <tr><td class="paramname">va</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="ga8d5300f9289c9d3ed0b64175aef3c8b8" name="ga8d5300f9289c9d3ed0b64175aef3c8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d5300f9289c9d3ed0b64175aef3c8b8">&#9670;&#160;</a></span>EZTR_MsgSContent_Vsnprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EZTR_MsgSContent_Vsnprintf </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list</td>          <td class="paramname"><span class="paramname"><em>va</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A modified version of printf, specially designed to handle message content. </p>
<p>see <a class="el" href="prinf_functions.html">EZTR Printf Functions</a> for more information on EZTR's custom printf behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td></td></tr>
    <tr><td class="paramname">count</td><td></td></tr>
    <tr><td class="paramname">format</td><td></td></tr>
    <tr><td class="paramname">va</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
