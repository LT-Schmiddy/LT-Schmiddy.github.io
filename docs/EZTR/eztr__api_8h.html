<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EZ Text Replacer for Zelda64Recomp: include_in_dependents/eztr_api.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">EZ Text Replacer for Zelda64Recomp<span id="projectnumber">&#160;2.0.0</span>
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('eztr__api_8h.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">eztr_api.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The main header for EZTR.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;modding.h&quot;</code><br />
<code>#include &quot;global.h&quot;</code><br />
</div>
<p><a href="eztr__api_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="union_e_z_t_r___msg_buffer___raw.html">EZTR_MsgBuffer_Raw</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The message buffers type as defined in the Majora's Mask decompilation.  <a href="union_e_z_t_r___msg_buffer___raw.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_z_t_r___msg_buffer___partition.html">EZTR_MsgBuffer_Partition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The message buffer, but with the header and content regions defined as seperate arrays.  <a href="struct_e_z_t_r___msg_buffer___partition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_z_t_r___msg_buffer___data.html">EZTR_MsgBuffer_Data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The message buffer, with the header represented as its individual members.  <a href="struct_e_z_t_r___msg_buffer___data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A union of the three MsgBuffer structs, and the primary type for interacting with message data.  <a href="union_e_z_t_r___msg_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aee449f5b0e2f0d3889d8d60dec8f4a9b" id="r_aee449f5b0e2f0d3889d8d60dec8f4a9b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee449f5b0e2f0d3889d8d60dec8f4a9b">EZTR_MOD_ID_STR</a>&#160;&#160;&#160;&quot;MM_EZ_Text_Replacer_API&quot;</td></tr>
<tr class="memdesc:aee449f5b0e2f0d3889d8d60dec8f4a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mod id string for EZTR.  <br /></td></tr>
<tr class="separator:aee449f5b0e2f0d3889d8d60dec8f4a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad14b66a7cec9afac8513682484a7db0" id="r_aad14b66a7cec9afac8513682484a7db0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad14b66a7cec9afac8513682484a7db0">EZTR_IMPORT</a>(func)</td></tr>
<tr class="separator:aad14b66a7cec9afac8513682484a7db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7cf8dddbe98e509571e1e014202c6bf" id="r_ac7cf8dddbe98e509571e1e014202c6bf"><td class="memItemLeft" align="right" valign="top"><a id="ac7cf8dddbe98e509571e1e014202c6bf" name="ac7cf8dddbe98e509571e1e014202c6bf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EZTR_PACK_STRUCT</b></td></tr>
<tr class="separator:ac7cf8dddbe98e509571e1e014202c6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655e473417efd577f51df531a31b3bd7" id="r_a655e473417efd577f51df531a31b3bd7"><td class="memItemLeft" align="right" valign="top"><a id="a655e473417efd577f51df531a31b3bd7" name="a655e473417efd577f51df531a31b3bd7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EZTR_MSG_HIGHEST_ID</b>&#160;&#160;&#160;0x354C</td></tr>
<tr class="separator:a655e473417efd577f51df531a31b3bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12bec64c933d00f52577814e8b06caa" id="r_ad12bec64c933d00f52577814e8b06caa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad12bec64c933d00f52577814e8b06caa">EZTR_MSG_BUFFER_SIZE</a>&#160;&#160;&#160;1280</td></tr>
<tr class="memdesc:ad12bec64c933d00f52577814e8b06caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The the full size of message buffer, in bytes.  <br /></td></tr>
<tr class="separator:ad12bec64c933d00f52577814e8b06caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f41684ba815f8a6662ef215789e253" id="r_ad7f41684ba815f8a6662ef215789e253"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7f41684ba815f8a6662ef215789e253">EZTR_MSG_BUFFER_WIDE_SIZE</a>&#160;&#160;&#160;640</td></tr>
<tr class="memdesc:ad7f41684ba815f8a6662ef215789e253"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum length of buffer in two-byte characters (<code>wchar</code>).  <br /></td></tr>
<tr class="separator:ad7f41684ba815f8a6662ef215789e253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06df59bd8ff9e8804cd1ca508dc80985" id="r_a06df59bd8ff9e8804cd1ca508dc80985"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06df59bd8ff9e8804cd1ca508dc80985">EZTR_MSG_HEADER_SIZE</a>&#160;&#160;&#160;11</td></tr>
<tr class="memdesc:a06df59bd8ff9e8804cd1ca508dc80985"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the message buffer's header region, in bytes.  <br /></td></tr>
<tr class="separator:a06df59bd8ff9e8804cd1ca508dc80985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade961148a3cd71fa56275f0af9a45e26" id="r_ade961148a3cd71fa56275f0af9a45e26"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade961148a3cd71fa56275f0af9a45e26">EZTR_MSG_CONTENT_SIZE</a>&#160;&#160;&#160;1269</td></tr>
<tr class="memdesc:ade961148a3cd71fa56275f0af9a45e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the message buffer's content region, in bytes.  <br /></td></tr>
<tr class="separator:ade961148a3cd71fa56275f0af9a45e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c2c40b0ec80b67a6afe71853c5c716" id="r_a58c2c40b0ec80b67a6afe71853c5c716"><td class="memItemLeft" align="right" valign="top"><a id="a58c2c40b0ec80b67a6afe71853c5c716" name="a58c2c40b0ec80b67a6afe71853c5c716"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EZTR_MSG_ENDING_CHAR</b>&#160;&#160;&#160;'\xBF'</td></tr>
<tr class="separator:a58c2c40b0ec80b67a6afe71853c5c716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908211a8f5a31288ff8c5123790e2d7d" id="r_a908211a8f5a31288ff8c5123790e2d7d"><td class="memItemLeft" align="right" valign="top"><a id="a908211a8f5a31288ff8c5123790e2d7d" name="a908211a8f5a31288ff8c5123790e2d7d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EZTR_PIPE_CHAR</b>&#160;&#160;&#160;'|'</td></tr>
<tr class="separator:a908211a8f5a31288ff8c5123790e2d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f8cdd082541b542b8a0c90f9e2cee0" id="r_a29f8cdd082541b542b8a0c90f9e2cee0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29f8cdd082541b542b8a0c90f9e2cee0">EZTR_CUSTOM_MSG_HANDLE_NAME</a>(name_suffix)</td></tr>
<tr class="memdesc:a29f8cdd082541b542b8a0c90f9e2cee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses to set/get the actual symbol name for custom message handles If you want to add a prefix/suffix to your custom message handles globally, it can be done here.  <br /></td></tr>
<tr class="separator:a29f8cdd082541b542b8a0c90f9e2cee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd4c9646967113b1f3215c33843a3d7" id="r_a7dd4c9646967113b1f3215c33843a3d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7dd4c9646967113b1f3215c33843a3d7">EZTR_DEFINE_CUSTOM_MSG_HANDLE_NO_EXPORT</a>(name)</td></tr>
<tr class="memdesc:a7dd4c9646967113b1f3215c33843a3d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a non-exported CustomMsgHandle object.  <br /></td></tr>
<tr class="separator:a7dd4c9646967113b1f3215c33843a3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112f8c80f439bbcb9c1fe6b04170fe00" id="r_a112f8c80f439bbcb9c1fe6b04170fe00"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a112f8c80f439bbcb9c1fe6b04170fe00">EZTR_DEFINE_CUSTOM_MSG_HANDLE</a>(name)</td></tr>
<tr class="memdesc:a112f8c80f439bbcb9c1fe6b04170fe00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a CustomMsgHandle object.  <br /></td></tr>
<tr class="separator:a112f8c80f439bbcb9c1fe6b04170fe00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc0de54255e72ccfbb93bd54517254f" id="r_acdc0de54255e72ccfbb93bd54517254f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdc0de54255e72ccfbb93bd54517254f">EZTR_DECLARE_CUSTOM_MSG_HANDLE</a>(name)</td></tr>
<tr class="memdesc:acdc0de54255e72ccfbb93bd54517254f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a declaration for a CustomMsgHandle object.  <br /></td></tr>
<tr class="separator:acdc0de54255e72ccfbb93bd54517254f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726f3d2456c0acd0da0f73e9138de370" id="r_a726f3d2456c0acd0da0f73e9138de370"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a726f3d2456c0acd0da0f73e9138de370">EZTR_IMPORT_CUSTOM_MSG_HANDLE</a>(mod_str,  name_suffix)</td></tr>
<tr class="memdesc:a726f3d2456c0acd0da0f73e9138de370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares and imports a CustomMsgHandle object from another mod.  <br /></td></tr>
<tr class="separator:a726f3d2456c0acd0da0f73e9138de370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e093f08327ca500c2e45143d94d3565" id="r_a9e093f08327ca500c2e45143d94d3565"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e093f08327ca500c2e45143d94d3565">EZTR_IMPORT_CUSTOM_MSG_HANDLE_NO_PREFIX</a>(mod_str,  name)</td></tr>
<tr class="memdesc:a9e093f08327ca500c2e45143d94d3565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares and imports a CustomMsgHandle object from another mod.  <br /></td></tr>
<tr class="separator:a9e093f08327ca500c2e45143d94d3565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14da8fca7f6659b1d98bcd6026498201" id="r_a14da8fca7f6659b1d98bcd6026498201"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14da8fca7f6659b1d98bcd6026498201">EZTR_GET_CUSTOM_MSG_ID</a>(handle)</td></tr>
<tr class="memdesc:a14da8fca7f6659b1d98bcd6026498201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the textId from a custom message handle.  <br /></td></tr>
<tr class="separator:a14da8fca7f6659b1d98bcd6026498201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488a0c39d416b763314c4b194807c5e5" id="r_a488a0c39d416b763314c4b194807c5e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a488a0c39d416b763314c4b194807c5e5">EZTR_HNAME</a>(name_suffix)</td></tr>
<tr class="memdesc:a488a0c39d416b763314c4b194807c5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for <code><a class="el" href="#a29f8cdd082541b542b8a0c90f9e2cee0" title="Uses to set/get the actual symbol name for custom message handles If you want to add a prefix/suffix ...">EZTR_CUSTOM_MSG_HANDLE_NAME()</a></code>  <br /></td></tr>
<tr class="separator:a488a0c39d416b763314c4b194807c5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460cf0c3dd365f18ebb0b3e939b992db" id="r_a460cf0c3dd365f18ebb0b3e939b992db"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a460cf0c3dd365f18ebb0b3e939b992db">EZTR_GET_ID</a>(handle)</td></tr>
<tr class="memdesc:a460cf0c3dd365f18ebb0b3e939b992db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the textId from a custom message handle.  <br /></td></tr>
<tr class="separator:a460cf0c3dd365f18ebb0b3e939b992db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bd5b4fa086a6baf377da8e21b478b3" id="r_a04bd5b4fa086a6baf377da8e21b478b3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04bd5b4fa086a6baf377da8e21b478b3">EZTR_MSG_CALLBACK</a>(fname)</td></tr>
<tr class="memdesc:a04bd5b4fa086a6baf377da8e21b478b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A macro to easily create message callback functions.  <br /></td></tr>
<tr class="separator:a04bd5b4fa086a6baf377da8e21b478b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716f6a6679ad9e38a4f93a18ad54ece5" id="r_a716f6a6679ad9e38a4f93a18ad54ece5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a716f6a6679ad9e38a4f93a18ad54ece5">EZTR_ON_INIT</a>&#160;&#160;&#160;RECOMP_CALLBACK(&quot;MM_EZ_Text_Replacer_API&quot;, EZTR_OnInit)</td></tr>
<tr class="memdesc:a716f6a6679ad9e38a4f93a18ad54ece5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to declare a function that should run after EZTR has finished initializing.  <br /></td></tr>
<tr class="separator:a716f6a6679ad9e38a4f93a18ad54ece5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809bff127d072380b5fc99b3721051c7" id="r_a809bff127d072380b5fc99b3721051c7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a809bff127d072380b5fc99b3721051c7">EZTR_NO_VALUE</a>&#160;&#160;&#160;0xffff</td></tr>
<tr class="memdesc:a809bff127d072380b5fc99b3721051c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by certain members of <code>EZTR_MsgData</code> (and the message header generally) to indicate that said member is not in use.  <br /></td></tr>
<tr class="separator:a809bff127d072380b5fc99b3721051c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af14c939010aeb8ff548788278b5e1b0f" id="r_af14c939010aeb8ff548788278b5e1b0f"><td class="memItemLeft" align="right" valign="top">typedef u16(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af14c939010aeb8ff548788278b5e1b0f">EZTR_CustomMsgHandle</a>) (_EZTR_CustomMsgHandleSetter *setter)</td></tr>
<tr class="memdesc:af14c939010aeb8ff548788278b5e1b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type declaration for custom message handle.  <br /></td></tr>
<tr class="separator:af14c939010aeb8ff548788278b5e1b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ba35ad8684a0265d641043caa81bc5" id="r_ad9ba35ad8684a0265d641043caa81bc5"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a>) (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf, u16 textId, PlayState *play)</td></tr>
<tr class="memdesc:ad9ba35ad8684a0265d641043caa81bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function pointer type for message callbacks.  <br /></td></tr>
<tr class="separator:ad9ba35ad8684a0265d641043caa81bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac7a0819ee2ed5d0e939030ae98b9171c" id="r_ac7a0819ee2ed5d0e939030ae98b9171c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7a0819ee2ed5d0e939030ae98b9171c">EZTR_TextBoxType</a> { <br />
&#160;&#160;<b>EZTR_STANDARD_TEXT_BOX_I</b> = 0X00
, <b>EZTR_WOODEN_SIGN_BACKGROUND</b> = 0X01
, <b>EZTR_TRANSLUSCENT_BLUE_TEXT_BOX</b> = 0X02
, <b>EZTR_OCARINA_STAFF</b> = 0X03
, <br />
&#160;&#160;<b>EZTR_INVISIBLE_TEXT_BOX_I</b> = 0X04
, <b>EZTR_INVISIBLE_TEXT_BOX_II</b> = 0X05
, <b>EZTR_STANDARD_TEXT_BOX_II</b> = 0X06
, <b>EZTR_INVISIBLE_TEXT_BOX</b> = 0X07
, <br />
&#160;&#160;<b>EZTR_BLUE_TEXT_BOX</b> = 0X08
, <b>EZTR_RED_TEXT_BOX_I</b> = 0X09
, <b>EZTR_INVISIBLE_TEXT_BOX_III</b> = 0X0A
, <b>EZTR_INVISIBLE_TEXT_BOX_IV</b> = 0X0B
, <br />
&#160;&#160;<b>EZTR_INVISIBLE_TEXT_BOX_V</b> = 0X0C
, <b>EZTR_BOMBERS_NOTEBOOK</b> = 0X0D
, <b>EZTR_INVISIBLE_TEXT_BOX_VI</b> = 0X0E
, <b>EZTR_RED_TEXT_BOX_II</b> = 0X0F
<br />
 }</td></tr>
<tr class="memdesc:ac7a0819ee2ed5d0e939030ae98b9171c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used in the message header to indicate the style of textbox used for the message.  <a href="#ac7a0819ee2ed5d0e939030ae98b9171c">More...</a><br /></td></tr>
<tr class="separator:ac7a0819ee2ed5d0e939030ae98b9171c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716ef28fc50ca98601dddf9fb05240cb" id="r_a716ef28fc50ca98601dddf9fb05240cb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a716ef28fc50ca98601dddf9fb05240cb">EZTR_TextBoxIcon</a> { <br />
&#160;&#160;<b>EZTR_ICON_NOTHING</b> = 0x00
, <b>EZTR_ICON_GREEN_RUPEE</b> = 0x01
, <b>EZTR_ICON_BLUE_RUPEE</b> = 0x02
, <b>EZTR_ICON_WHITE_RUPEE</b> = 0x03
, <br />
&#160;&#160;<b>EZTR_ICON_RED_RUPEE</b> = 0x04
, <b>EZTR_ICON_PURPLE_RUPEE</b> = 0x05
, <b>EZTR_ICON_WHITE_RUPEE_1</b> = 0x06
, <b>EZTR_ICON_ORANGE_RUPEE</b> = 0x07
, <br />
&#160;&#160;<b>EZTR_ICON_ADULT_WALLET</b> = 0x08
, <b>EZTR_ICON_GIANTS_WALLET</b> = 0x09
, <b>EZTR_ICON_RECOVERY_HEART</b> = 0x0A
, <b>EZTR_ICON_RECOVERY_HEART_1</b> = 0x0B
, <br />
&#160;&#160;<b>EZTR_ICON_PIECE_OF_HEART</b> = 0x0C
, <b>EZTR_ICON_HEART_CONTAINER</b> = 0x0D
, <b>EZTR_ICON_SMALL_MAGIC_JAR</b> = 0x0E
, <b>EZTR_ICON_LARGE_MAGIC_JAR</b> = 0x0F
, <br />
&#160;&#160;<b>EZTR_ICON_RECOVERY_HEART_2</b> = 0x10
, <b>EZTR_ICON_STRAY_FAIRY</b> = 0x11
, <b>EZTR_ICON_RECOVERY_HEART_3</b> = 0x12
, <b>EZTR_ICON_RECOVERY_HEART_4</b> = 0x13
, <br />
&#160;&#160;<b>EZTR_ICON_BOMB</b> = 0x14
, <b>EZTR_ICON_BOMB_1</b> = 0x15
, <b>EZTR_ICON_BOMB_2</b> = 0x16
, <b>EZTR_ICON_BOMB_3</b> = 0x17
, <br />
&#160;&#160;<b>EZTR_ICON_BOMB_4</b> = 0x18
, <b>EZTR_ICON_DEKU_STICK</b> = 0x19
, <b>EZTR_ICON_BOMBCHU</b> = 0x1A
, <b>EZTR_ICON_BOMB_BAG</b> = 0x1B
, <br />
&#160;&#160;<b>EZTR_ICON_BIG_BOMB_BAG</b> = 0x1C
, <b>EZTR_ICON_BIGGER_BOMB_BAG</b> = 0x1D
, <b>EZTR_ICON_HEROS_BOW</b> = 0x1E
, <b>EZTR_ICON_HEROS_BOW_1</b> = 0x1F
, <br />
&#160;&#160;<b>EZTR_ICON_HEROS_BOW_2</b> = 0x20
, <b>EZTR_ICON_HEROS_BOW_3</b> = 0x21
, <b>EZTR_ICON_QUIVER</b> = 0x22
, <b>EZTR_ICON_BIG_QUIVER</b> = 0x23
, <br />
&#160;&#160;<b>EZTR_ICON_BIGGEST_QUIVER</b> = 0x24
, <b>EZTR_ICON_FIRE_ARROW</b> = 0x25
, <b>EZTR_ICON_ICE_ARROW</b> = 0x26
, <b>EZTR_ICON_LIGHT_ARROW</b> = 0x27
, <br />
&#160;&#160;<b>EZTR_ICON_DEKU_NUT</b> = 0x28
, <b>EZTR_ICON_DEKU_NUT_1</b> = 0x29
, <b>EZTR_ICON_DEKU_NUT_2</b> = 0x2A
, <b>EZTR_ICON_NOTHING_1</b> = 0x2B
, <br />
&#160;&#160;<b>EZTR_ICON_NOTHING_2</b> = 0x2C
, <b>EZTR_ICON_NOTHING_3</b> = 0x2D
, <b>EZTR_ICON_NOTHING_4</b> = 0x2E
, <b>EZTR_ICON_NOTHING_5</b> = 0x2F
, <br />
&#160;&#160;<b>EZTR_ICON_NOTHING_6</b> = 0x30
, <b>EZTR_ICON_NOTHING_7</b> = 0x31
, <b>EZTR_ICON_HEROS_SHIELD</b> = 0x32
, <b>EZTR_ICON_MIRROR_SHIELD</b> = 0x33
, <br />
&#160;&#160;<b>EZTR_ICON_POWDER_KEG</b> = 0x34
, <b>EZTR_ICON_MAGIC_BEAN</b> = 0x35
, <b>EZTR_ICON_PICTOGRAPH_BOX</b> = 0x36
, <b>EZTR_ICON_KOKIRI_SWORD</b> = 0x37
, <br />
&#160;&#160;<b>EZTR_ICON_RAZOR_SWORD</b> = 0x38
, <b>EZTR_ICON_GILDED_SWORD</b> = 0x39
, <b>EZTR_ICON_FIERCE_DEITYS_SWORD</b> = 0x3A
, <b>EZTR_ICON_GREAT_FAIRYS_SWORD</b> = 0x3B
, <br />
&#160;&#160;<b>EZTR_ICON_SMALL_KEY</b> = 0x3C
, <b>EZTR_ICON_BOSS_KEY</b> = 0x3D
, <b>EZTR_ICON_DUNGEON_MAP</b> = 0x3E
, <b>EZTR_ICON_COMPASS</b> = 0x3F
, <br />
&#160;&#160;<b>EZTR_ICON_POWDER_KEG_1</b> = 0x40
, <b>EZTR_ICON_HOOKSHOT</b> = 0x41
, <b>EZTR_ICON_LENS_OF_TRUTH</b> = 0x42
, <b>EZTR_ICON_PICTOGRAPH_BOX_1</b> = 0x43
, <br />
&#160;&#160;<b>EZTR_ICON_FISHING_ROD</b> = 0x44
, <b>EZTR_ICON_NOTHING_8</b> = 0x45
, <b>EZTR_ICON_NOTHING_9</b> = 0x46
, <b>EZTR_ICON_NOTHING_10</b> = 0x47
, <br />
&#160;&#160;<b>EZTR_ICON_NOTHING_11</b> = 0x48
, <b>EZTR_ICON_NOTHING_12</b> = 0x49
, <b>EZTR_ICON_NOTHING_13</b> = 0x4A
, <b>EZTR_ICON_NOTHING_14</b> = 0x4B
, <br />
&#160;&#160;<b>EZTR_ICON_OCARINA_OF_TIME</b> = 0x4C
, <b>EZTR_ICON_NOTHING_15</b> = 0x4D
, <b>EZTR_ICON_NOTHING_16</b> = 0x4E
, <b>EZTR_ICON_NOTHING_17</b> = 0x4F
, <br />
&#160;&#160;<b>EZTR_ICON_BOMBERS_NOTEBOOK</b> = 0x50
, <b>EZTR_ICON_NOTHING_18</b> = 0x51
, <b>EZTR_ICON_GOLD_SKULLTULA_TOKEN</b> = 0x52
, <b>EZTR_ICON_NOTHING_19</b> = 0x53
, <br />
&#160;&#160;<b>EZTR_ICON_NOTHING_20</b> = 0x54
, <b>EZTR_ICON_ODOLWAS_REMAINS</b> = 0x55
, <b>EZTR_ICON_GOHTS_REMAINS</b> = 0x56
, <b>EZTR_ICON_GYORGS_REMAINS</b> = 0x57
, <br />
&#160;&#160;<b>EZTR_ICON_TWINMOLDS_REMAINS</b> = 0x58
, <b>EZTR_ICON_RED_POTION</b> = 0x59
, <b>EZTR_ICON_EMPTY_BOTTLE</b> = 0x5A
, <b>EZTR_ICON_RED_POTION_1</b> = 0x5B
, <br />
&#160;&#160;<b>EZTR_ICON_GREEN_POTION</b> = 0x5C
, <b>EZTR_ICON_BLUE_POTION</b> = 0x5D
, <b>EZTR_ICON_FAIRYS_SPIRIT</b> = 0x5E
, <b>EZTR_ICON_DEKU_PRINCESS</b> = 0x5F
, <br />
&#160;&#160;<b>EZTR_ICON_MILK</b> = 0x60
, <b>EZTR_ICON_MILK_HALF</b> = 0x61
, <b>EZTR_ICON_FISH</b> = 0x62
, <b>EZTR_ICON_BUG</b> = 0x63
, <br />
&#160;&#160;<b>EZTR_ICON_BLUE_FIRE</b> = 0x64
, <b>EZTR_ICON_POE</b> = 0x65
, <b>EZTR_ICON_BIG_POE</b> = 0x66
, <b>EZTR_ICON_SPRING_WATER</b> = 0x67
, <br />
&#160;&#160;<b>EZTR_ICON_HOT_SPRING_WATER</b> = 0x68
, <b>EZTR_ICON_ZORA_EGG</b> = 0x69
, <b>EZTR_ICON_GOLD_DUST</b> = 0x6A
, <b>EZTR_ICON_MUSHROOM</b> = 0x6B
, <br />
&#160;&#160;<b>EZTR_ICON_NOTHING_21</b> = 0x6C
, <b>EZTR_ICON_NOTHING_22</b> = 0x6D
, <b>EZTR_ICON_SEAHORSE</b> = 0x6E
, <b>EZTR_ICON_CHATEAU_ROMANI</b> = 0x6F
, <br />
&#160;&#160;<b>EZTR_ICON_HYLIAN_LOACH</b> = 0x70
, <b>EZTR_ICON_NOTHING_23</b> = 0x71
, <b>EZTR_ICON_NOTHING_24</b> = 0x72
, <b>EZTR_ICON_NOTHING_25</b> = 0x73
, <br />
&#160;&#160;<b>EZTR_ICON_NOTHING_26</b> = 0x74
, <b>EZTR_ICON_NOTHING_27</b> = 0x75
, <b>EZTR_ICON_NOTHING_28</b> = 0x76
, <b>EZTR_ICON_NOTHING_29</b> = 0x77
, <br />
&#160;&#160;<b>EZTR_ICON_DEKU_MASK</b> = 0x78
, <b>EZTR_ICON_GORON_MASK</b> = 0x79
, <b>EZTR_ICON_ZORA_MASK</b> = 0x7A
, <b>EZTR_ICON_FIERCE_DEITY_MASK</b> = 0x7B
, <br />
&#160;&#160;<b>EZTR_ICON_MASK_OF_TRUTH</b> = 0x7C
, <b>EZTR_ICON_KAFEIS_MASK</b> = 0x7D
, <b>EZTR_ICON_ALL_NIGHT_MASK</b> = 0x7E
, <b>EZTR_ICON_BUNNY_HOOD</b> = 0x7F
, <br />
&#160;&#160;<b>EZTR_ICON_KEATON_MASK</b> = 0x80
, <b>EZTR_ICON_GARO_MASK</b> = 0x81
, <b>EZTR_ICON_ROMANI_MASK</b> = 0x82
, <b>EZTR_ICON_CIRCUS_LEADERS_MASK</b> = 0x83
, <br />
&#160;&#160;<b>EZTR_ICON_POSTMANS_HAT</b> = 0x84
, <b>EZTR_ICON_COUPLES_MASK</b> = 0x85
, <b>EZTR_ICON_GREAT_FAIRYS_MASK</b> = 0x86
, <b>EZTR_ICON_GIBDO_MASK</b> = 0x87
, <br />
&#160;&#160;<b>EZTR_ICON_DON_GEROS_MASK</b> = 0x88
, <b>EZTR_ICON_KAMAROS_MASK</b> = 0x89
, <b>EZTR_ICON_CAPTAINS_HAT</b> = 0x8A
, <b>EZTR_ICON_STONE_MASK</b> = 0x8B
, <br />
&#160;&#160;<b>EZTR_ICON_BREMEN_MASK</b> = 0x8C
, <b>EZTR_ICON_BLAST_MASK</b> = 0x8D
, <b>EZTR_ICON_MASK_OF_SCENTS</b> = 0x8E
, <b>EZTR_ICON_GIANTS_MASK</b> = 0x8F
, <br />
&#160;&#160;<b>EZTR_ICON_NOTHING_30</b> = 0x90
, <b>EZTR_ICON_CHATEAU_ROMANI_1</b> = 0x91
, <b>EZTR_ICON_MILK_1</b> = 0x92
, <b>EZTR_ICON_GOLD_DUST_1</b> = 0x93
, <br />
&#160;&#160;<b>EZTR_ICON_HYLIAN_LOACH_1</b> = 0x94
, <b>EZTR_ICON_SEAHORSE_1</b> = 0x95
, <b>EZTR_ICON_MOONS_TEAR</b> = 0x96
, <b>EZTR_ICON_TOWN_TITLE_DEED</b> = 0x97
, <br />
&#160;&#160;<b>EZTR_ICON_SWAMP_TITLE_DEED</b> = 0x98
, <b>EZTR_ICON_MOUNTAIN_TITLE_DEED</b> = 0x99
, <b>EZTR_ICON_OCEAN_TITLE_DEED</b> = 0x9A
, <b>EZTR_ICON_NOTHING_31</b> = 0x9B
, <br />
&#160;&#160;<b>EZTR_ICON_NOTHING_32</b> = 0x9C
, <b>EZTR_ICON_NOTHING_33</b> = 0x9D
, <b>EZTR_ICON_NOTHING_34</b> = 0x9E
, <b>EZTR_ICON_NOTHING_35</b> = 0x9F
, <br />
&#160;&#160;<b>EZTR_ICON_ROOM_KEY</b> = 0xA0
, <b>EZTR_ICON_SPECIAL_DELIVERY_TO_MAMA</b> = 0xA1
, <b>EZTR_ICON_NOTHING_36</b> = 0xA2
, <b>EZTR_ICON_NOTHING_37</b> = 0xA3
, <br />
&#160;&#160;<b>EZTR_ICON_NOTHING_38</b> = 0xA4
, <b>EZTR_ICON_NOTHING_39</b> = 0xA5
, <b>EZTR_ICON_NOTHING_40</b> = 0xA6
, <b>EZTR_ICON_NOTHING_41</b> = 0xA7
, <br />
&#160;&#160;<b>EZTR_ICON_NOTHING_42</b> = 0xA8
, <b>EZTR_ICON_NOTHING_43</b> = 0xA9
, <b>EZTR_ICON_LETTER_TO_KAFEI</b> = 0xAA
, <b>EZTR_ICON_PENDANT_OF_MEMORIES</b> = 0xAB
, <br />
&#160;&#160;<b>EZTR_ICON_NOTHING_44</b> = 0xAC
, <b>EZTR_ICON_NOTHING_45</b> = 0xAD
, <b>EZTR_ICON_NOTHING_46</b> = 0xAE
, <b>EZTR_ICON_NOTHING_47</b> = 0xAF
, <br />
&#160;&#160;<b>EZTR_ICON_NOTHING_48</b> = 0xB0
, <b>EZTR_ICON_NOTHING_49</b> = 0xB1
, <b>EZTR_ICON_NOTHING_50</b> = 0xB2
, <b>EZTR_ICON_TINGLES_MAP</b> = 0xB3
, <br />
&#160;&#160;<b>EZTR_ICON_TINGLES_MAP_1</b> = 0xB4
, <b>EZTR_ICON_TINGLES_MAP_2</b> = 0xB5
, <b>EZTR_ICON_TINGLES_MAP_3</b> = 0xB6
, <b>EZTR_ICON_TINGLES_MAP_4</b> = 0xB7
, <br />
&#160;&#160;<b>EZTR_ICON_TINGLES_MAP_5</b> = 0xB8
, <b>EZTR_ICON_TINGLES_MAP_6</b> = 0xB9
, <b>EZTR_ICON_NOTHING_51</b> = 0xBA
, <b>EZTR_ICON_NOTHING_52</b> = 0xBB
, <br />
&#160;&#160;<b>EZTR_ICON_NOTHING_53</b> = 0xBC
, <b>EZTR_ICON_NOTHING_54</b> = 0xBD
, <b>EZTR_ICON_NOTHING_55</b> = 0xBE
, <b>EZTR_ICON_NOTHING_56</b> = 0xBF
, <br />
&#160;&#160;<b>EZTR_ICON_NOTHING_57</b> = 0xC0
, <b>EZTR_ICON_NOTHING_58</b> = 0xC1
, <b>EZTR_ICON_NOTHING_59</b> = 0xC2
, <b>EZTR_ICON_NOTHING_60</b> = 0xC3
, <br />
&#160;&#160;<b>EZTR_ICON_NOTHING_61</b> = 0xC4
, <b>EZTR_ICON_NOTHING_62</b> = 0xC5
, <b>EZTR_ICON_NOTHING_63</b> = 0xC6
, <b>EZTR_ICON_NOTHING_64</b> = 0xC7
, <br />
&#160;&#160;<b>EZTR_ICON_NOTHING_65</b> = 0xC8
, <b>EZTR_ICON_NOTHING_66</b> = 0xC9
, <b>EZTR_ICON_NOTHING_67</b> = 0xCA
, <b>EZTR_ICON_NOTHING_68</b> = 0xCB
, <br />
&#160;&#160;<b>EZTR_ICON_NOTHING_69</b> = 0xCC
, <b>EZTR_ICON_NOTHING_70</b> = 0xCD
, <b>EZTR_ICON_NOTHING_71</b> = 0xCE
, <b>EZTR_ICON_NOTHING_72</b> = 0xCF
, <br />
&#160;&#160;<b>EZTR_ICON_NOTHING_73</b> = 0xD0
, <b>EZTR_ICON_NOTHING_74</b> = 0xD1
, <b>EZTR_ICON_NOTHING_75</b> = 0xD2
, <b>EZTR_ICON_NOTHING_76</b> = 0xD3
, <br />
&#160;&#160;<b>EZTR_ICON_NOTHING_77</b> = 0xD4
, <b>EZTR_ICON_NOTHING_78</b> = 0xD5
, <b>EZTR_ICON_NOTHING_79</b> = 0xD6
, <b>EZTR_ICON_NOTHING_80</b> = 0xD7
, <br />
&#160;&#160;<b>EZTR_ICON_SMALL_BLACK_LINE</b> = 0xD8
, <b>EZTR_ICON_SMALL_BLACK_LINE_1</b> = 0xD9
, <b>EZTR_ICON_SMALL_BLACK_LINE_2</b> = 0xDA
, <b>EZTR_ICON_SMALL_BLACK_LINE_3</b> = 0xDB
, <br />
&#160;&#160;<b>EZTR_ICON_ANJU</b> = 0xDC
, <b>EZTR_ICON_KAFEI</b> = 0xDD
, <b>EZTR_ICON_CURIOSITY_SHOP_OWNER</b> = 0xDE
, <b>EZTR_ICON_BOMB_SHOP_OWNERS_MOTHER</b> = 0xDF
, <br />
&#160;&#160;<b>EZTR_ICON_ROMANI</b> = 0xE0
, <b>EZTR_ICON_CREMIA</b> = 0xE1
, <b>EZTR_ICON_MAYOR_DOTOUR</b> = 0xE2
, <b>EZTR_ICON_MADAME_AROMA</b> = 0xE3
, <br />
&#160;&#160;<b>EZTR_ICON_TOTO</b> = 0xE4
, <b>EZTR_ICON_GORMAN</b> = 0xE5
, <b>EZTR_ICON_POSTMAN</b> = 0xE6
, <b>EZTR_ICON_ROSA_SISTERS</b> = 0xE7
, <br />
&#160;&#160;<b>EZTR_ICON_TOILET_HAND</b> = 0xE8
, <b>EZTR_ICON_GRANNY</b> = 0xE9
, <b>EZTR_ICON_KAMARO</b> = 0xEA
, <b>EZTR_ICON_GROG</b> = 0xEB
, <br />
&#160;&#160;<b>EZTR_ICON_GORMAN_BROTHERS</b> = 0xEC
, <b>EZTR_ICON_SHIRO</b> = 0xED
, <b>EZTR_ICON_GURU_GURU</b> = 0xEE
, <b>EZTR_ICON_BOMBERS</b> = 0xEF
, <br />
&#160;&#160;<b>EZTR_ICON_EXCLAMATION_MARK</b> = 0xF0
, <b>EZTR_ICON_NOTHING_81</b> = 0xF1
, <b>EZTR_ICON_NOTHING_82</b> = 0xF2
, <b>EZTR_ICON_NOTHING_83</b> = 0xF3
, <br />
&#160;&#160;<b>EZTR_ICON_NOTHING_84</b> = 0xF4
, <b>EZTR_ICON_NOTHING_85</b> = 0xF5
, <b>EZTR_ICON_NOTHING_86</b> = 0xF6
, <b>EZTR_ICON_NOTHING_87</b> = 0xF7
, <br />
&#160;&#160;<b>EZTR_ICON_NOTHING_88</b> = 0xF8
, <b>EZTR_ICON_NOTHING_89</b> = 0xF9
, <b>EZTR_ICON_NOTHING_90</b> = 0xFA
, <b>EZTR_ICON_NOTHING_91</b> = 0xFB
, <br />
&#160;&#160;<b>EZTR_ICON_NOTHING_92</b> = 0xFC
, <b>EZTR_ICON_NOTHING_93</b> = 0xFD
, <b>EZTR_ICON_NO_ICON</b> = 0xFE
<br />
 }</td></tr>
<tr class="memdesc:a716ef28fc50ca98601dddf9fb05240cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used in the message header to indicate a display icon for the message.  <a href="#a716ef28fc50ca98601dddf9fb05240cb">More...</a><br /></td></tr>
<tr class="separator:a716ef28fc50ca98601dddf9fb05240cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8001f916103311b701e403d62f776074" id="r_a8001f916103311b701e403d62f776074"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8001f916103311b701e403d62f776074">EZTR_Basic_ReplaceBuffer</a> (u16 textId, <a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf, <a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a> callback)</td></tr>
<tr class="memdesc:a8001f916103311b701e403d62f776074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a replacement of a vanilla message by copying from a buffer defined by the user.  <br /></td></tr>
<tr class="separator:a8001f916103311b701e403d62f776074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130700fec5bb6f9469a5c41847f2fbb6" id="r_a130700fec5bb6f9469a5c41847f2fbb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a130700fec5bb6f9469a5c41847f2fbb6">EZTR_Basic_ReplaceText</a> (u16 textId, u8 text_box_type, u8 text_box_y_pos, u8 display_icon, u16 next_message_id, u16 first_item_rupees, u16 second_item_rupees, bool pipe_escape_bytes, char *content, <a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a> callback)</td></tr>
<tr class="memdesc:a130700fec5bb6f9469a5c41847f2fbb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a replacement of a vanilla message by defining the header attributes and message content.  <br /></td></tr>
<tr class="separator:a130700fec5bb6f9469a5c41847f2fbb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3d2fef5e69105140806673fce4d985" id="r_a2c3d2fef5e69105140806673fce4d985"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c3d2fef5e69105140806673fce4d985">EZTR_Basic_ReplaceTextEmpty</a> (u16 textId, <a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a> callback)</td></tr>
<tr class="memdesc:a2c3d2fef5e69105140806673fce4d985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a replacement of a vanilla message, where the replacement message is empty.  <br /></td></tr>
<tr class="separator:a2c3d2fef5e69105140806673fce4d985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae288fd74c3f0df7ebafbbd4f795a68f6" id="r_ae288fd74c3f0df7ebafbbd4f795a68f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae288fd74c3f0df7ebafbbd4f795a68f6">EZTR_Basic_AddCustomBuffer</a> (<a class="el" href="#af14c939010aeb8ff548788278b5e1b0f">EZTR_CustomMsgHandle</a> handle, <a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf, <a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a> callback)</td></tr>
<tr class="memdesc:ae288fd74c3f0df7ebafbbd4f795a68f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a brand new (i.e: custom) message by copying from a buffer defined by the user.  <br /></td></tr>
<tr class="separator:ae288fd74c3f0df7ebafbbd4f795a68f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5d26d7477edd4ba4ec2be15766e136" id="r_aba5d26d7477edd4ba4ec2be15766e136"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba5d26d7477edd4ba4ec2be15766e136">EZTR_Basic_AddCustomText</a> (<a class="el" href="#af14c939010aeb8ff548788278b5e1b0f">EZTR_CustomMsgHandle</a> handle, u8 text_box_type, u8 text_box_y_pos, u8 display_icon, u16 next_message_id, u16 first_item_rupees, u16 second_item_rupees, bool pipe_escape_bytes, char *content, <a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a> callback)</td></tr>
<tr class="memdesc:aba5d26d7477edd4ba4ec2be15766e136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a brand new (i.e: custom) message by defining the header attributes and message content.  <br /></td></tr>
<tr class="separator:aba5d26d7477edd4ba4ec2be15766e136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8bd9e796160a2657adf03a77703baf" id="r_aed8bd9e796160a2657adf03a77703baf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed8bd9e796160a2657adf03a77703baf">EZTR_Basic_AddCustomTextEmpty</a> (<a class="el" href="#af14c939010aeb8ff548788278b5e1b0f">EZTR_CustomMsgHandle</a> handle, <a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a> callback)</td></tr>
<tr class="memdesc:aed8bd9e796160a2657adf03a77703baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a brand new (i.e: custom) message, where the replacement message is empty.  <br /></td></tr>
<tr class="separator:aed8bd9e796160a2657adf03a77703baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a12f735129bbe48bc0780c47fa7665" id="r_a52a12f735129bbe48bc0780c47fa7665"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52a12f735129bbe48bc0780c47fa7665">EZTR_Basic_ReplaceCustomBuffer</a> (<a class="el" href="#af14c939010aeb8ff548788278b5e1b0f">EZTR_CustomMsgHandle</a> handle, <a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf, <a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a> callback)</td></tr>
<tr class="memdesc:a52a12f735129bbe48bc0780c47fa7665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a replacement for a custom message by copying from a buffer defined by the user.  <br /></td></tr>
<tr class="separator:a52a12f735129bbe48bc0780c47fa7665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc25b8ecceac76911ea9dfc91d94d9e8" id="r_abc25b8ecceac76911ea9dfc91d94d9e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc25b8ecceac76911ea9dfc91d94d9e8">EZTR_Basic_ReplaceCustomText</a> (<a class="el" href="#af14c939010aeb8ff548788278b5e1b0f">EZTR_CustomMsgHandle</a> handle, u8 text_box_type, u8 text_box_y_pos, u8 display_icon, u16 next_message_id, u16 first_item_rupees, u16 second_item_rupees, bool pipe_escape_bytes, char *content, <a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a> callback)</td></tr>
<tr class="memdesc:abc25b8ecceac76911ea9dfc91d94d9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a replacement of a custom message by defining the header attributes and message content.  <br /></td></tr>
<tr class="separator:abc25b8ecceac76911ea9dfc91d94d9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21eaf9a0b5b451ff82363418ce9eb10" id="r_ac21eaf9a0b5b451ff82363418ce9eb10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac21eaf9a0b5b451ff82363418ce9eb10">EZTR_Basic_ReplaceCustomTextEmpty</a> (<a class="el" href="#af14c939010aeb8ff548788278b5e1b0f">EZTR_CustomMsgHandle</a> handle, <a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a> callback)</td></tr>
<tr class="memdesc:ac21eaf9a0b5b451ff82363418ce9eb10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a replacement of a custom message, where the replacement message is empty.  <br /></td></tr>
<tr class="separator:ac21eaf9a0b5b451ff82363418ce9eb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c2beef126a75f0222b69759008120e" id="r_a39c2beef126a75f0222b69759008120e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39c2beef126a75f0222b69759008120e">EZTR_MsgBuffer_Create</a> ()</td></tr>
<tr class="memdesc:a39c2beef126a75f0222b69759008120e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new message buffer object on the heap.  <br /></td></tr>
<tr class="separator:a39c2beef126a75f0222b69759008120e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fc35479c7e6fee9e6049f473363177" id="r_a09fc35479c7e6fee9e6049f473363177"><td class="memItemLeft" align="right" valign="top"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09fc35479c7e6fee9e6049f473363177">EZTR_MsgBuffer_CreateFromStr</a> (char *src)</td></tr>
<tr class="memdesc:a09fc35479c7e6fee9e6049f473363177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new message buffer object on the heap, and copies <code>src</code> into it.  <br /></td></tr>
<tr class="separator:a09fc35479c7e6fee9e6049f473363177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91896add7333589c5d04730e84c8f6f4" id="r_a91896add7333589c5d04730e84c8f6f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91896add7333589c5d04730e84c8f6f4">EZTR_MsgBuffer_CreateFromStrN</a> (char *src, size_t len)</td></tr>
<tr class="memdesc:a91896add7333589c5d04730e84c8f6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new message buffer object on the heap, and copies <code>src</code> into it for up to <code>len</code> bytes.  <br /></td></tr>
<tr class="separator:a91896add7333589c5d04730e84c8f6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b268a005666834e39511fd0dc2c469" id="r_a27b268a005666834e39511fd0dc2c469"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27b268a005666834e39511fd0dc2c469">EZTR_MsgBuffer_Destroy</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf)</td></tr>
<tr class="memdesc:a27b268a005666834e39511fd0dc2c469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees/destroys a message buffer.  <br /></td></tr>
<tr class="separator:a27b268a005666834e39511fd0dc2c469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020cddc8868430e6afd77733907d6139" id="r_a020cddc8868430e6afd77733907d6139"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a020cddc8868430e6afd77733907d6139">EZTR_MsgBuffer_Copy</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *dst, char *src)</td></tr>
<tr class="memdesc:a020cddc8868430e6afd77733907d6139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from <code>src</code> into the message buffer <code>dst</code>.  <br /></td></tr>
<tr class="separator:a020cddc8868430e6afd77733907d6139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46abdcae0cc0572a9b3d6474f01bc62" id="r_aa46abdcae0cc0572a9b3d6474f01bc62"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa46abdcae0cc0572a9b3d6474f01bc62">EZTR_MsgBuffer_NCopy</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *dst, char *src, size_t len)</td></tr>
<tr class="memdesc:aa46abdcae0cc0572a9b3d6474f01bc62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from <code>src</code> into the message buffer <code>dst</code>, up to <code>len</code> bytes.  <br /></td></tr>
<tr class="separator:aa46abdcae0cc0572a9b3d6474f01bc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b931bdaf93270ddc7ed445cf699b1fe" id="r_a8b931bdaf93270ddc7ed445cf699b1fe"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b931bdaf93270ddc7ed445cf699b1fe">EZTR_MsgBuffer_Len</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf)</td></tr>
<tr class="memdesc:a8b931bdaf93270ddc7ed445cf699b1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the message buffer's stored data, in bytes.  <br /></td></tr>
<tr class="separator:a8b931bdaf93270ddc7ed445cf699b1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4370a73be9636af6f60dfb954342cedc" id="r_a4370a73be9636af6f60dfb954342cedc"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4370a73be9636af6f60dfb954342cedc">EZTR_MsgBuffer_ContentLen</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf)</td></tr>
<tr class="memdesc:a4370a73be9636af6f60dfb954342cedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the message buffer's content region, in bytes.  <br /></td></tr>
<tr class="separator:a4370a73be9636af6f60dfb954342cedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad149fb2e9d2c8fa3e0034ac54a61a678" id="r_ad149fb2e9d2c8fa3e0034ac54a61a678"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad149fb2e9d2c8fa3e0034ac54a61a678">EZTR_MsgBuffer_WriteDefaultHeader</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf)</td></tr>
<tr class="memdesc:ad149fb2e9d2c8fa3e0034ac54a61a678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a message buffer's header to default values.  <br /></td></tr>
<tr class="separator:ad149fb2e9d2c8fa3e0034ac54a61a678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578d94107d666a42c08bb3ad73fd8f33" id="r_a578d94107d666a42c08bb3ad73fd8f33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a578d94107d666a42c08bb3ad73fd8f33">EZTR_MsgBuffer_WriteHeader</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf, u8 text_box_type, u8 text_box_y_pos, u8 display_icon, u16 next_message_id, u16 first_item_rupees, u16 second_item_rupees)</td></tr>
<tr class="separator:a578d94107d666a42c08bb3ad73fd8f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa740d70e876eb91c758c0686f06cb6" id="r_a6fa740d70e876eb91c758c0686f06cb6"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fa740d70e876eb91c758c0686f06cb6">EZTR_MsgBuffer_GetTextBoxType</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf)</td></tr>
<tr class="memdesc:a6fa740d70e876eb91c758c0686f06cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the text_box_type from a message buffer's header.  <br /></td></tr>
<tr class="separator:a6fa740d70e876eb91c758c0686f06cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530d275045043f28d94b762b36daf66e" id="r_a530d275045043f28d94b762b36daf66e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a530d275045043f28d94b762b36daf66e">EZTR_MsgBuffer_SetTextBoxType</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf, u8 type)</td></tr>
<tr class="memdesc:a530d275045043f28d94b762b36daf66e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the text_box_type of the message buffer's header.  <br /></td></tr>
<tr class="separator:a530d275045043f28d94b762b36daf66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5e6b7691b750e998d5258cd180ef8e" id="r_acb5e6b7691b750e998d5258cd180ef8e"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb5e6b7691b750e998d5258cd180ef8e">EZTR_MsgBuffer_GetTextBoxYPos</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf)</td></tr>
<tr class="memdesc:acb5e6b7691b750e998d5258cd180ef8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the text_box_y_pos from a message buffer's header.  <br /></td></tr>
<tr class="separator:acb5e6b7691b750e998d5258cd180ef8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf1d5e1b0fc9637427f0c758bff0da9" id="r_abaf1d5e1b0fc9637427f0c758bff0da9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abaf1d5e1b0fc9637427f0c758bff0da9">EZTR_MsgBuffer_SetTextBoxYPos</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf, u8 pos)</td></tr>
<tr class="memdesc:abaf1d5e1b0fc9637427f0c758bff0da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the text_box_y_pos of the message buffer's header.  <br /></td></tr>
<tr class="separator:abaf1d5e1b0fc9637427f0c758bff0da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc50f85b99782d5aa97f8d122d1587d" id="r_a4bc50f85b99782d5aa97f8d122d1587d"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bc50f85b99782d5aa97f8d122d1587d">EZTR_MsgBuffer_GetTextBoxDisplayIcon</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf)</td></tr>
<tr class="memdesc:a4bc50f85b99782d5aa97f8d122d1587d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the display_icon from a message buffer's header.  <br /></td></tr>
<tr class="separator:a4bc50f85b99782d5aa97f8d122d1587d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6d8ba4bde04faab7330540c4d284cd" id="r_acf6d8ba4bde04faab7330540c4d284cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf6d8ba4bde04faab7330540c4d284cd">EZTR_MsgBuffer_SetTextBoxDisplayIcon</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf, u8 icon)</td></tr>
<tr class="memdesc:acf6d8ba4bde04faab7330540c4d284cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the display_icon of the message buffer's header.  <br /></td></tr>
<tr class="separator:acf6d8ba4bde04faab7330540c4d284cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015f838b68601c44d38be12780cb0834" id="r_a015f838b68601c44d38be12780cb0834"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a015f838b68601c44d38be12780cb0834">EZTR_MsgBuffer_GetNextMsg</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf)</td></tr>
<tr class="memdesc:a015f838b68601c44d38be12780cb0834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the next_message_id from a message buffer's header.  <br /></td></tr>
<tr class="separator:a015f838b68601c44d38be12780cb0834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f857fd4054f0b076012a85b8b14f08" id="r_a46f857fd4054f0b076012a85b8b14f08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46f857fd4054f0b076012a85b8b14f08">EZTR_MsgBuffer_SetNextMsg</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf, u16 textId)</td></tr>
<tr class="memdesc:a46f857fd4054f0b076012a85b8b14f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the next_message_id of the message buffer's header.  <br /></td></tr>
<tr class="separator:a46f857fd4054f0b076012a85b8b14f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecbd0e2114b2169dac0254e15bb920f4" id="r_aecbd0e2114b2169dac0254e15bb920f4"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecbd0e2114b2169dac0254e15bb920f4">EZTR_MsgBuffer_GetFirstItemRupees</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf)</td></tr>
<tr class="memdesc:aecbd0e2114b2169dac0254e15bb920f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the first_item_rupees from a message buffer's header.  <br /></td></tr>
<tr class="separator:aecbd0e2114b2169dac0254e15bb920f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89663200d1aa9ffe42c27039bb2701d4" id="r_a89663200d1aa9ffe42c27039bb2701d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89663200d1aa9ffe42c27039bb2701d4">EZTR_MsgBuffer_SetFirstItemRupees</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf, u16 val)</td></tr>
<tr class="memdesc:a89663200d1aa9ffe42c27039bb2701d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the first_item_rupees of the message buffer's header.  <br /></td></tr>
<tr class="separator:a89663200d1aa9ffe42c27039bb2701d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2894fa932a1b5ab0429b26395eca921" id="r_aa2894fa932a1b5ab0429b26395eca921"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2894fa932a1b5ab0429b26395eca921">EZTR_MsgBuffer_GetSecondItemRupees</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf)</td></tr>
<tr class="memdesc:aa2894fa932a1b5ab0429b26395eca921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the second_item_rupees from a message buffer's header.  <br /></td></tr>
<tr class="separator:aa2894fa932a1b5ab0429b26395eca921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873aabed87f63550b8818174e16f7f63" id="r_a873aabed87f63550b8818174e16f7f63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a873aabed87f63550b8818174e16f7f63">EZTR_MsgBuffer_SetSecondItemRupees</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf, u16 val)</td></tr>
<tr class="memdesc:a873aabed87f63550b8818174e16f7f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the second_item_rupees of the message buffer's header.  <br /></td></tr>
<tr class="separator:a873aabed87f63550b8818174e16f7f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d9e959cd5fa20e5bdadb8cce347c22" id="r_af8d9e959cd5fa20e5bdadb8cce347c22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8d9e959cd5fa20e5bdadb8cce347c22">EZTR_MsgBuffer_Print</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf)</td></tr>
<tr class="memdesc:af8d9e959cd5fa20e5bdadb8cce347c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the contents of a message buffer to the console.  <br /></td></tr>
<tr class="separator:af8d9e959cd5fa20e5bdadb8cce347c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59379a5596f63ec6c0bcd7eb4fb7fd14" id="r_a59379a5596f63ec6c0bcd7eb4fb7fd14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59379a5596f63ec6c0bcd7eb4fb7fd14">EZTR_MsgBuffer_PrintFull</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf)</td></tr>
<tr class="memdesc:a59379a5596f63ec6c0bcd7eb4fb7fd14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the contents of a message buffer to the console.  <br /></td></tr>
<tr class="separator:a59379a5596f63ec6c0bcd7eb4fb7fd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21eec47bd44a5a81b37aa88561d17146" id="r_a21eec47bd44a5a81b37aa88561d17146"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21eec47bd44a5a81b37aa88561d17146">EZTR_MsgBuffer_GetContentPtr</a> (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf)</td></tr>
<tr class="memdesc:a21eec47bd44a5a81b37aa88561d17146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to the beginning of the content region for a desired message buffer.  <br /></td></tr>
<tr class="separator:a21eec47bd44a5a81b37aa88561d17146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdf97a6b5c9d99e1154d1709e6f2dc4" id="r_a9cdf97a6b5c9d99e1154d1709e6f2dc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cdf97a6b5c9d99e1154d1709e6f2dc4">EZTR_MsgSContent_SetEmpty</a> (char *cont)</td></tr>
<tr class="memdesc:a9cdf97a6b5c9d99e1154d1709e6f2dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the message message content as empty.A_BTN_STATE_IDLE.  <br /></td></tr>
<tr class="separator:a9cdf97a6b5c9d99e1154d1709e6f2dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affede5c9bbcd94fcedf72680c6ac3666" id="r_affede5c9bbcd94fcedf72680c6ac3666"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affede5c9bbcd94fcedf72680c6ac3666">EZTR_MsgSContent_Len</a> (char *cont)</td></tr>
<tr class="memdesc:affede5c9bbcd94fcedf72680c6ac3666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the length of the a message content string in bytes, not counting the '\xBF' termination character.  <br /></td></tr>
<tr class="separator:affede5c9bbcd94fcedf72680c6ac3666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942c2f98af6fe2a81428bdcfd8336183" id="r_a942c2f98af6fe2a81428bdcfd8336183"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a942c2f98af6fe2a81428bdcfd8336183">EZTR_MsgSContent_NCopy</a> (char *dst, char *src, size_t len)</td></tr>
<tr class="memdesc:a942c2f98af6fe2a81428bdcfd8336183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies message content from <code>src</code> into the <code>dst</code>, up to <code>len</code> bytes.  <br /></td></tr>
<tr class="separator:a942c2f98af6fe2a81428bdcfd8336183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663aa64051a106585368bd080dbfac91" id="r_a663aa64051a106585368bd080dbfac91"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a663aa64051a106585368bd080dbfac91">EZTR_MsgSContent_Copy</a> (char *dst, char *src)</td></tr>
<tr class="memdesc:a663aa64051a106585368bd080dbfac91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies message content from <code>src</code> into the <code>dst</code>.  <br /></td></tr>
<tr class="separator:a663aa64051a106585368bd080dbfac91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa144e4595b017537667babed825e67eb" id="r_aa144e4595b017537667babed825e67eb"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa144e4595b017537667babed825e67eb">EZTR_MsgSContent_NCat</a> (char *dst, char *src, size_t len)</td></tr>
<tr class="memdesc:aa144e4595b017537667babed825e67eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the message content of <code>src</code> onto the end of <code>dst</code>, up to <code>len</code> bytes from <code>src</code>.  <br /></td></tr>
<tr class="separator:aa144e4595b017537667babed825e67eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72647d2cb1cbb660f9cb86df6074241f" id="r_a72647d2cb1cbb660f9cb86df6074241f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72647d2cb1cbb660f9cb86df6074241f">EZTR_MsgSContent_Cat</a> (char *dst, char *src)</td></tr>
<tr class="memdesc:a72647d2cb1cbb660f9cb86df6074241f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the message content of <code>src</code> onto the end of <code>dst</code>.  <br /></td></tr>
<tr class="separator:a72647d2cb1cbb660f9cb86df6074241f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79545ea629e4fb127ad978a8518c310f" id="r_a79545ea629e4fb127ad978a8518c310f"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79545ea629e4fb127ad978a8518c310f">EZTR_MsgSContent_NCmp</a> (char *str1, char *str2, size_t len)</td></tr>
<tr class="memdesc:a79545ea629e4fb127ad978a8518c310f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares up to <code>len</code> bytes of two message content strings.  <br /></td></tr>
<tr class="separator:a79545ea629e4fb127ad978a8518c310f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf2e411789c0ad0061471c74ba87204" id="r_aedf2e411789c0ad0061471c74ba87204"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedf2e411789c0ad0061471c74ba87204">EZTR_MsgSContent_Cmp</a> (char *str1, char *str2)</td></tr>
<tr class="memdesc:aedf2e411789c0ad0061471c74ba87204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two message content strings.  <br /></td></tr>
<tr class="separator:aedf2e411789c0ad0061471c74ba87204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a90a7c7b0c76188aedb8da5a39ec08" id="r_a37a90a7c7b0c76188aedb8da5a39ec08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37a90a7c7b0c76188aedb8da5a39ec08">EZTR_MsgSContent_Printf</a> (const char *format,...)</td></tr>
<tr class="memdesc:a37a90a7c7b0c76188aedb8da5a39ec08"><td class="mdescLeft">&#160;</td><td class="mdescRight">A modified version of printf, specially designed to handle message content.  <br /></td></tr>
<tr class="separator:a37a90a7c7b0c76188aedb8da5a39ec08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ff11ca18271df5512699d276b6ba1e" id="r_ad1ff11ca18271df5512699d276b6ba1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1ff11ca18271df5512699d276b6ba1e">EZTR_MsgSContent_PrintfLine</a> (const char *format,...)</td></tr>
<tr class="memdesc:ad1ff11ca18271df5512699d276b6ba1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A modified version of printf, specially designed to handle message content.  <br /></td></tr>
<tr class="separator:ad1ff11ca18271df5512699d276b6ba1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9672989bc812f2b03a238fe422e2f19" id="r_af9672989bc812f2b03a238fe422e2f19"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9672989bc812f2b03a238fe422e2f19">EZTR_MsgSContent_Sprintf</a> (char *buffer, const char *format,...)</td></tr>
<tr class="memdesc:af9672989bc812f2b03a238fe422e2f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">A modified version of printf, specially designed to handle message content.  <br /></td></tr>
<tr class="separator:af9672989bc812f2b03a238fe422e2f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c28d2307ddff188da8705b7b426ceb" id="r_ac7c28d2307ddff188da8705b7b426ceb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7c28d2307ddff188da8705b7b426ceb">EZTR_MsgSContent_Snprintf</a> (char *buffer, size_t count, const char *format,...)</td></tr>
<tr class="memdesc:ac7c28d2307ddff188da8705b7b426ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A modified version of printf, specially designed to handle message content.  <br /></td></tr>
<tr class="separator:ac7c28d2307ddff188da8705b7b426ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5300f9289c9d3ed0b64175aef3c8b8" id="r_a8d5300f9289c9d3ed0b64175aef3c8b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d5300f9289c9d3ed0b64175aef3c8b8">EZTR_MsgSContent_Vsnprintf</a> (char *buffer, size_t count, const char *format, va_list va)</td></tr>
<tr class="memdesc:a8d5300f9289c9d3ed0b64175aef3c8b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A modified version of printf, specially designed to handle message content.  <br /></td></tr>
<tr class="separator:a8d5300f9289c9d3ed0b64175aef3c8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de78728bd6fb85269e97d135ec69180" id="r_a9de78728bd6fb85269e97d135ec69180"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9de78728bd6fb85269e97d135ec69180">EZTR_MsgSContent_Vprintf</a> (const char *format, va_list va)</td></tr>
<tr class="memdesc:a9de78728bd6fb85269e97d135ec69180"><td class="mdescLeft">&#160;</td><td class="mdescRight">A modified version of printf, specially designed to handle message content.  <br /></td></tr>
<tr class="separator:a9de78728bd6fb85269e97d135ec69180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34be36f8427a9e5af06d8b3dabcf34c2" id="r_a34be36f8427a9e5af06d8b3dabcf34c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34be36f8427a9e5af06d8b3dabcf34c2">EZTR_MsgSContent_Fctprintf</a> (void(*out)(char character, void *arg), void *arg, const char *format,...)</td></tr>
<tr class="memdesc:a34be36f8427a9e5af06d8b3dabcf34c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A modified version of printf, specially designed to handle message content.  <br /></td></tr>
<tr class="separator:a34be36f8427a9e5af06d8b3dabcf34c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The main header for EZTR. </p>
<dl class="section version"><dt>Version</dt><dd>2.0.0 </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a29f8cdd082541b542b8a0c90f9e2cee0" name="a29f8cdd082541b542b8a0c90f9e2cee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f8cdd082541b542b8a0c90f9e2cee0">&#9670;&#160;</a></span>EZTR_CUSTOM_MSG_HANDLE_NAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EZTR_CUSTOM_MSG_HANDLE_NAME</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>name_suffix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">EZTR_CustomMsgHandle_##name_suffix</div>
</div><!-- fragment -->
<p>Uses to set/get the actual symbol name for custom message handles If you want to add a prefix/suffix to your custom message handles globally, it can be done here. </p>

</div>
</div>
<a id="acdc0de54255e72ccfbb93bd54517254f" name="acdc0de54255e72ccfbb93bd54517254f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc0de54255e72ccfbb93bd54517254f">&#9670;&#160;</a></span>EZTR_DECLARE_CUSTOM_MSG_HANDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EZTR_DECLARE_CUSTOM_MSG_HANDLE</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">u16 <a class="code hl_define" href="#a29f8cdd082541b542b8a0c90f9e2cee0">EZTR_CUSTOM_MSG_HANDLE_NAME</a>(name)(_EZTR_CustomMsgHandleSetter* setter)</div>
<div class="ttc" id="aeztr__api_8h_html_a29f8cdd082541b542b8a0c90f9e2cee0"><div class="ttname"><a href="#a29f8cdd082541b542b8a0c90f9e2cee0">EZTR_CUSTOM_MSG_HANDLE_NAME</a></div><div class="ttdeci">#define EZTR_CUSTOM_MSG_HANDLE_NAME(name_suffix)</div><div class="ttdoc">Uses to set/get the actual symbol name for custom message handles If you want to add a prefix/suffix ...</div><div class="ttdef"><b>Definition</b> eztr_api.h:151</div></div>
</div><!-- fragment -->
<p>Creates a declaration for a CustomMsgHandle object. </p>
<p>Use this reference handles created in other .c files. Also works in headers. </p>

</div>
</div>
<a id="a112f8c80f439bbcb9c1fe6b04170fe00" name="a112f8c80f439bbcb9c1fe6b04170fe00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a112f8c80f439bbcb9c1fe6b04170fe00">&#9670;&#160;</a></span>EZTR_DEFINE_CUSTOM_MSG_HANDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EZTR_DEFINE_CUSTOM_MSG_HANDLE</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">RECOMP_EXPORT \</div>
<div class="line">u16 <a class="code hl_define" href="#a29f8cdd082541b542b8a0c90f9e2cee0">EZTR_CUSTOM_MSG_HANDLE_NAME</a>(name)(_EZTR_CustomMsgHandleSetter* setter) \</div>
<div class="line">__EZTR_CUSTOM_MSG_HANDLE_BODY(name)</div>
</div><!-- fragment -->
<p>Creates a CustomMsgHandle object. </p>
<p>This is the primary method for creating handles for custom messages. You'll need to use this macro inside one of your .c files (outside of any functions) to create the handle itself. Use <code>EZTR_DECLARE_CUSTOM_MSG_HANDLE</code> to access the handle from other files.</p>
<p>See the <code><a class="el" href="#af14c939010aeb8ff548788278b5e1b0f" title="The type declaration for custom message handle.">EZTR_CustomMsgHandle</a></code> documentation for more information about handles and how they work. </p>

</div>
</div>
<a id="a7dd4c9646967113b1f3215c33843a3d7" name="a7dd4c9646967113b1f3215c33843a3d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd4c9646967113b1f3215c33843a3d7">&#9670;&#160;</a></span>EZTR_DEFINE_CUSTOM_MSG_HANDLE_NO_EXPORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EZTR_DEFINE_CUSTOM_MSG_HANDLE_NO_EXPORT</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">u16 <a class="code hl_define" href="#a29f8cdd082541b542b8a0c90f9e2cee0">EZTR_CUSTOM_MSG_HANDLE_NAME</a>(name)(_EZTR_CustomMsgHandleSetter* setter) \</div>
<div class="line">__EZTR_CUSTOM_MSG_HANDLE_BODY(name)</div>
</div><!-- fragment -->
<p>Creates a non-exported CustomMsgHandle object. </p>
<p>Most mods are not installed in a vacuum. You should consider exporting your custom message handles so that other mods can access the messages you define if need be (compatibility patches, addons, etc.) </p>

</div>
</div>
<a id="a14da8fca7f6659b1d98bcd6026498201" name="a14da8fca7f6659b1d98bcd6026498201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14da8fca7f6659b1d98bcd6026498201">&#9670;&#160;</a></span>EZTR_GET_CUSTOM_MSG_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EZTR_GET_CUSTOM_MSG_ID</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">handle(NULL)</div>
</div><!-- fragment -->
<p>Gets the textId from a custom message handle. </p>
<p>A more readable alternative to <code>handle(NULL)</code> </p>

</div>
</div>
<a id="a460cf0c3dd365f18ebb0b3e939b992db" name="a460cf0c3dd365f18ebb0b3e939b992db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a460cf0c3dd365f18ebb0b3e939b992db">&#9670;&#160;</a></span>EZTR_GET_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EZTR_GET_ID</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_define" href="#a14da8fca7f6659b1d98bcd6026498201">EZTR_GET_CUSTOM_MSG_ID</a>(handle)</div>
<div class="ttc" id="aeztr__api_8h_html_a14da8fca7f6659b1d98bcd6026498201"><div class="ttname"><a href="#a14da8fca7f6659b1d98bcd6026498201">EZTR_GET_CUSTOM_MSG_ID</a></div><div class="ttdeci">#define EZTR_GET_CUSTOM_MSG_ID(handle)</div><div class="ttdoc">Gets the textId from a custom message handle.</div><div class="ttdef"><b>Definition</b> eztr_api.h:206</div></div>
</div><!-- fragment -->
<p>Gets the textId from a custom message handle. </p>
<p>A more readable alternative to <code>handle(NULL)</code>, and shorthand for <code><a class="el" href="#a14da8fca7f6659b1d98bcd6026498201" title="Gets the textId from a custom message handle.">EZTR_GET_CUSTOM_MSG_ID()</a></code> </p>

</div>
</div>
<a id="a488a0c39d416b763314c4b194807c5e5" name="a488a0c39d416b763314c4b194807c5e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488a0c39d416b763314c4b194807c5e5">&#9670;&#160;</a></span>EZTR_HNAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EZTR_HNAME</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>name_suffix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_define" href="#a29f8cdd082541b542b8a0c90f9e2cee0">EZTR_CUSTOM_MSG_HANDLE_NAME</a>(name_suffix)</div>
</div><!-- fragment -->
<p>Shorthand for <code><a class="el" href="#a29f8cdd082541b542b8a0c90f9e2cee0" title="Uses to set/get the actual symbol name for custom message handles If you want to add a prefix/suffix ...">EZTR_CUSTOM_MSG_HANDLE_NAME()</a></code> </p>
<p>Useful if you want to use global prefixes. </p>

</div>
</div>
<a id="aad14b66a7cec9afac8513682484a7db0" name="aad14b66a7cec9afac8513682484a7db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad14b66a7cec9afac8513682484a7db0">&#9670;&#160;</a></span>EZTR_IMPORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EZTR_IMPORT</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>func</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">func</div>
</div><!-- fragment -->
</div>
</div>
<a id="a726f3d2456c0acd0da0f73e9138de370" name="a726f3d2456c0acd0da0f73e9138de370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726f3d2456c0acd0da0f73e9138de370">&#9670;&#160;</a></span>EZTR_IMPORT_CUSTOM_MSG_HANDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EZTR_IMPORT_CUSTOM_MSG_HANDLE</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mod_str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>name_suffix</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">RECOMP_IMPORT(mod_str, u16 EZTR_CustomMsgHandle_##name_suffix(_EZTR_CustomMsgHandleSetter* setter))</div>
</div><!-- fragment -->
<p>Declares and imports a CustomMsgHandle object from another mod. </p>
<p>This will allow you to use and interact with custom messages from other mods. </p>

</div>
</div>
<a id="a9e093f08327ca500c2e45143d94d3565" name="a9e093f08327ca500c2e45143d94d3565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e093f08327ca500c2e45143d94d3565">&#9670;&#160;</a></span>EZTR_IMPORT_CUSTOM_MSG_HANDLE_NO_PREFIX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EZTR_IMPORT_CUSTOM_MSG_HANDLE_NO_PREFIX</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mod_str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">RECOMP_IMPORT(mod_str, u16 name(_EZTR_CustomMsgHandleSetter* setter))</div>
</div><!-- fragment -->
<p>Declares and imports a CustomMsgHandle object from another mod. </p>
<p>This will allow you to use and interact with custom messages from other mods. </p>

</div>
</div>
<a id="aee449f5b0e2f0d3889d8d60dec8f4a9b" name="aee449f5b0e2f0d3889d8d60dec8f4a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee449f5b0e2f0d3889d8d60dec8f4a9b">&#9670;&#160;</a></span>EZTR_MOD_ID_STR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EZTR_MOD_ID_STR&#160;&#160;&#160;&quot;MM_EZ_Text_Replacer_API&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The mod id string for EZTR. </p>
<p>The <code><a class="el" href="eztr__api_8h.html" title="The main header for EZTR.">eztr_api.h</a></code> imports all the functions and events needed for EZTR, so you probably won't need to use this directly. </p>

</div>
</div>
<a id="ad12bec64c933d00f52577814e8b06caa" name="ad12bec64c933d00f52577814e8b06caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12bec64c933d00f52577814e8b06caa">&#9670;&#160;</a></span>EZTR_MSG_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EZTR_MSG_BUFFER_SIZE&#160;&#160;&#160;1280</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The the full size of message buffer, in bytes. </p>
<p>Also equivalent to maximum length of buffer in single-byte characters (<code>char</code>). </p>

</div>
</div>
<a id="ad7f41684ba815f8a6662ef215789e253" name="ad7f41684ba815f8a6662ef215789e253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f41684ba815f8a6662ef215789e253">&#9670;&#160;</a></span>EZTR_MSG_BUFFER_WIDE_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EZTR_MSG_BUFFER_WIDE_SIZE&#160;&#160;&#160;640</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum length of buffer in two-byte characters (<code>wchar</code>). </p>
<p>Not really used, but included for parity with the base game. </p>

</div>
</div>
<a id="a04bd5b4fa086a6baf377da8e21b478b3" name="a04bd5b4fa086a6baf377da8e21b478b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04bd5b4fa086a6baf377da8e21b478b3">&#9670;&#160;</a></span>EZTR_MSG_CALLBACK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EZTR_MSG_CALLBACK</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>fname</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordtype">void</span> fname(<a class="code hl_union" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a>* buf, u16 textId, PlayState* play)</div>
<div class="ttc" id="aunion_e_z_t_r___msg_buffer_html"><div class="ttname"><a href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a></div><div class="ttdoc">A union of the three MsgBuffer structs, and the primary type for interacting with message data.</div><div class="ttdef"><b>Definition</b> eztr_api.h:136</div></div>
</div><!-- fragment -->
<p>A macro to easily create message callback functions. </p>
<p>This macro can be used to create both the function definition and declaration (if one is needed);</p>
<ul>
<li>To create the definition, use <code><a class="el" href="#a04bd5b4fa086a6baf377da8e21b478b3" title="A macro to easily create message callback functions.">EZTR_MSG_CALLBACK(my_callback)</a> {...}</code></li>
<li>To create the declaration, use <code><a class="el" href="#a04bd5b4fa086a6baf377da8e21b478b3" title="A macro to easily create message callback functions.">EZTR_MSG_CALLBACK(my_callback)</a>;</code></li>
</ul>
<p><code>my_callback</code> can then be passed to <code>EZTR_Basic_ReplaceText_WithCallback()</code> or <code>EZTR_Basic_ReplaceText_EmptyWithCallback()</code> as the callback argument. </p>

</div>
</div>
<a id="ade961148a3cd71fa56275f0af9a45e26" name="ade961148a3cd71fa56275f0af9a45e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade961148a3cd71fa56275f0af9a45e26">&#9670;&#160;</a></span>EZTR_MSG_CONTENT_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EZTR_MSG_CONTENT_SIZE&#160;&#160;&#160;1269</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size of the message buffer's content region, in bytes. </p>
<p>Useful if you need to loop throught a buffer's content. </p>

</div>
</div>
<a id="a06df59bd8ff9e8804cd1ca508dc80985" name="a06df59bd8ff9e8804cd1ca508dc80985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06df59bd8ff9e8804cd1ca508dc80985">&#9670;&#160;</a></span>EZTR_MSG_HEADER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EZTR_MSG_HEADER_SIZE&#160;&#160;&#160;11</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size of the message buffer's header region, in bytes. </p>
<p>Also servers as the starting index of the message buffer's content region. </p>

</div>
</div>
<a id="a809bff127d072380b5fc99b3721051c7" name="a809bff127d072380b5fc99b3721051c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a809bff127d072380b5fc99b3721051c7">&#9670;&#160;</a></span>EZTR_NO_VALUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EZTR_NO_VALUE&#160;&#160;&#160;0xffff</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used by certain members of <code>EZTR_MsgData</code> (and the message header generally) to indicate that said member is not in use. </p>
<p>The header members in question are:</p>
<ul>
<li><code>next_message_id</code></li>
<li><code>first_item_rupees</code></li>
<li><code>second_item_rupees</code> </li>
</ul>

</div>
</div>
<a id="a716f6a6679ad9e38a4f93a18ad54ece5" name="a716f6a6679ad9e38a4f93a18ad54ece5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716f6a6679ad9e38a4f93a18ad54ece5">&#9670;&#160;</a></span>EZTR_ON_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EZTR_ON_INIT&#160;&#160;&#160;RECOMP_CALLBACK(&quot;MM_EZ_Text_Replacer_API&quot;, EZTR_OnInit)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to declare a function that should run after EZTR has finished initializing. </p>
<p>This is where you should declare all of your text replacements. You don't want to declare them during a <code>recomp_on_init</code> event, since EZTR may not have initialized itself yet, and attempting to declare text replacements before that will cause a crash. Additionally, declaring messaged here will ensure that mod priority order is respected when declaring replacements.</p>
<p>Example: <code>EZTR_ON_INIT void declare_my_text() {...}</code> </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="af14c939010aeb8ff548788278b5e1b0f" name="af14c939010aeb8ff548788278b5e1b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14c939010aeb8ff548788278b5e1b0f">&#9670;&#160;</a></span>EZTR_CustomMsgHandle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef u16(* EZTR_CustomMsgHandle) (_EZTR_CustomMsgHandleSetter *setter)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type declaration for custom message handle. </p>
<p>These are created using either the <code><a class="el" href="#a112f8c80f439bbcb9c1fe6b04170fe00" title="Creates a CustomMsgHandle object.">EZTR_DEFINE_CUSTOM_MSG_HANDLE()</a></code> macro or the <code><a class="el" href="#a7dd4c9646967113b1f3215c33843a3d7" title="Creates a non-exported CustomMsgHandle object.">EZTR_DEFINE_CUSTOM_MSG_HANDLE_NO_EXPORT()</a></code> macro in one of your .c files, outside of any functions.</p>
<p>It's worth noting that a custom message handle is actually a function, defined through macros. In brief, here are the important things to know:</p><ul>
<li>The handler's only argument is a pointer that EZTR uses internally. Modders don't need to use it.</li>
<li>You can retrieve the handle's textId by calling it with NULL as the argument (<code>handle(NULL)</code>)</li>
<li>By default, the handle can only have its textId assigned once (See below on how to change this behavior).</li>
<li>Handles created using <code>EZTR_DEFINE_CUSTOM_MSG_HANDLE</code>, the recommended macro for creating custom message handles, are marked with <code>RECOMP_EXPORT</code>.</li>
</ul>
<p>This implementation was decided on to ensure that the textIds of custom messages are not lost through variable reassignments, and to facilitate mods potentially needing to access/modify each other's messages.</p>
<p>For those interested in the technical details: The function's only argument is used by EZTR to set the textId variable when a custom message is assigned to it, and to check that the assignment was a success.</p>
<p>The version of the handle function included in this header stores the textId in a static variable, and includes logic that will only allow the textId to be set once. If a second attempt to set the ID is made, an error message is printed. Rather than change a handle's textId, you should change the stored message at that id.</p>
<p>If you want to change the behavior of the handles, you can write your own custom message handle functions, but it's not recommended. </p>

</div>
</div>
<a id="ad9ba35ad8684a0265d641043caa81bc5" name="ad9ba35ad8684a0265d641043caa81bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ba35ad8684a0265d641043caa81bc5">&#9670;&#160;</a></span>EZTR_MsgCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* EZTR_MsgCallback) (<a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *buf, u16 textId, PlayState *play)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function pointer type for message callbacks. </p>
<p>To easily create functions that match this type, see the <code>EZTR_MSG_CALLBACK</code> macro. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a716ef28fc50ca98601dddf9fb05240cb" name="a716ef28fc50ca98601dddf9fb05240cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716ef28fc50ca98601dddf9fb05240cb">&#9670;&#160;</a></span>EZTR_TextBoxIcon</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a716ef28fc50ca98601dddf9fb05240cb">EZTR_TextBoxIcon</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used in the message header to indicate a display icon for the message. </p>
<p>You can set the display icon by assigning to the <code>display_icon</code> member of EZTR_MsgData, or by using <code>EZTR_MsgBuffer_SetTextBoxDIsplayIcon()</code>.</p>
<p>Note that the value for not displaying an icon is <code>EZTR_ICON_NO_ICON</code>, and NOT</p>
<p><code>EZTR_ICON_NOTHING</code> or it's variants. </p>

</div>
</div>
<a id="ac7a0819ee2ed5d0e939030ae98b9171c" name="ac7a0819ee2ed5d0e939030ae98b9171c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a0819ee2ed5d0e939030ae98b9171c">&#9670;&#160;</a></span>EZTR_TextBoxType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ac7a0819ee2ed5d0e939030ae98b9171c">EZTR_TextBoxType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used in the message header to indicate the style of textbox used for the message. </p>
<p>You can set the text box type by assigning to the <code>text_box_type</code> member of EZTR_MsgData, or by using <code><a class="el" href="#a530d275045043f28d94b762b36daf66e" title="Sets the text_box_type of the message buffer&#39;s header.">EZTR_MsgBuffer_SetTextBoxType()</a></code>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae288fd74c3f0df7ebafbbd4f795a68f6" name="ae288fd74c3f0df7ebafbbd4f795a68f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae288fd74c3f0df7ebafbbd4f795a68f6">&#9670;&#160;</a></span>EZTR_Basic_AddCustomBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_Basic_AddCustomBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af14c939010aeb8ff548788278b5e1b0f">EZTR_CustomMsgHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare a brand new (i.e: custom) message by copying from a buffer defined by the user. </p>
<p>If you've defined a message using the MsgBuffer/MsgSContent functions, you can use this to set it (or, rather, a copy of it) as the new message.</p>
<p>To avoid potential ID conflicts between mods, the u16 textId for this message will be assigned by EZTR and will be accessable via the handle. See <code><a class="el" href="#af14c939010aeb8ff548788278b5e1b0f" title="The type declaration for custom message handle.">EZTR_CustomMsgHandle</a></code> for more information on how custom message handles work.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle for the new message. </td></tr>
    <tr><td class="paramname">buf</td><td>The message buffer to copy from. </td></tr>
    <tr><td class="paramname">callback</td><td>A function pointer to call right before this text is displayed. Useful for dynamic text. Set as NULL if you don't want to use a callback. See <code><a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5" title="The function pointer type for message callbacks.">EZTR_MsgCallback</a></code> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba5d26d7477edd4ba4ec2be15766e136" name="aba5d26d7477edd4ba4ec2be15766e136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5d26d7477edd4ba4ec2be15766e136">&#9670;&#160;</a></span>EZTR_Basic_AddCustomText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_Basic_AddCustomText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af14c939010aeb8ff548788278b5e1b0f">EZTR_CustomMsgHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>text_box_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>text_box_y_pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>display_icon</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>next_message_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>first_item_rupees</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>second_item_rupees</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>pipe_escape_bytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>content</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare a brand new (i.e: custom) message by defining the header attributes and message content. </p>
<p>This is probably the easiest method to declare new messages.</p>
<p>To avoid potential ID conflicts between mods, the u16 textId for this message will be assigned by EZTR and will be accessable via the handle. See <code><a class="el" href="#af14c939010aeb8ff548788278b5e1b0f" title="The type declaration for custom message handle.">EZTR_CustomMsgHandle</a></code> for more information on how custom message handles work.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle for the new message. </td></tr>
    <tr><td class="paramname">text_box_type</td><td>The style of textbox to display. Use the <code><a class="el" href="#ac7a0819ee2ed5d0e939030ae98b9171c" title="Used in the message header to indicate the style of textbox used for the message.">EZTR_TextBoxType</a></code> enum for more readable values. </td></tr>
    <tr><td class="paramname">text_box_y_pos</td><td>The vertical position of the textbox on-screen. </td></tr>
    <tr><td class="paramname">display_icon</td><td>Displays an icon in the textbox. Use the <code><a class="el" href="#a716ef28fc50ca98601dddf9fb05240cb" title="Used in the message header to indicate a display icon for the message.">EZTR_TextBoxIcon</a></code> enum for more readable values. Use <code>EZTR_ICON_NO_ICON</code> for no icon. </td></tr>
    <tr><td class="paramname">next_message_id</td><td>The next message to display. If there is no next message, or the next message is determined by code, use 0xFFFF or <code>EZTR_NO_VALUE</code>. </td></tr>
    <tr><td class="paramname">first_item_rupees</td><td>The price of the first item being offered for sale, if one exists. If there is no item, use 0xFFFF or <code>EZTR_NO_VALUE</code>. </td></tr>
    <tr><td class="paramname">second_item_rupees</td><td>The price of the second item being offered for sale, if one exists. If there is no item, use 0xFFFF or <code>EZTR_NO_VALUE</code>. </td></tr>
    <tr><td class="paramname">pipe_escape_bytes</td><td>If true, <code>content</code> is passed through <code>EZTR_MsgBuffer_Sprintf("%m", content)</code>. If false, then <code>content</code> is copied directly into storage. </td></tr>
    <tr><td class="paramname">content</td><td>The new text content to display. If you want empty content (for use with dynamic messages), use "\xBF". </td></tr>
    <tr><td class="paramname">callback</td><td>A function pointer to call right before this text is displayed. Useful for dynamic messages. Set as NULL if you don't want to use a callback. See <code><a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5" title="The function pointer type for message callbacks.">EZTR_MsgCallback</a></code> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed8bd9e796160a2657adf03a77703baf" name="aed8bd9e796160a2657adf03a77703baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8bd9e796160a2657adf03a77703baf">&#9670;&#160;</a></span>EZTR_Basic_AddCustomTextEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_Basic_AddCustomTextEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af14c939010aeb8ff548788278b5e1b0f">EZTR_CustomMsgHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare a brand new (i.e: custom) message, where the replacement message is empty. </p>
<p>This is primarily used if you want the message to be completely dynamically generated.</p>
<p>To avoid potential ID conflicts between mods, the u16 textId for this message will be assigned by EZTR and will be accessable via the handle. See <code><a class="el" href="#af14c939010aeb8ff548788278b5e1b0f" title="The type declaration for custom message handle.">EZTR_CustomMsgHandle</a></code> for more information on how custom message handles work.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle for the new message. </td></tr>
    <tr><td class="paramname">callback</td><td>A function pointer to call right before this text is displayed, in which you will construct the complete message buffer dynamically. See <code><a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5" title="The function pointer type for message callbacks.">EZTR_MsgCallback</a></code> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8001f916103311b701e403d62f776074" name="a8001f916103311b701e403d62f776074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8001f916103311b701e403d62f776074">&#9670;&#160;</a></span>EZTR_Basic_ReplaceBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_Basic_ReplaceBuffer </td>
          <td>(</td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>textId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare a replacement of a vanilla message by copying from a buffer defined by the user. </p>
<p>If you've defined a message using the MsgBuffer/MsgSContent functions, you can use this to set it (or, rather, a copy of it) as a replacement for a vanilla message.</p>
<p>Note that this function is meant for replacing vanilla messages only. It will not allow you to use a textId greater than 0x354C, as that is the highest textId value found in the vanilla game. If you wish to create/modify a custom message, see <code><a class="el" href="#ae288fd74c3f0df7ebafbbd4f795a68f6" title="Declare a brand new (i.e: custom) message by copying from a buffer defined by the user.">EZTR_Basic_AddCustomBuffer()</a></code> and <a class="el" href="#a52a12f735129bbe48bc0780c47fa7665" title="Declare a replacement for a custom message by copying from a buffer defined by the user.">EZTR_Basic_ReplaceCustomBuffer()</a>`</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textId</td><td>The id of the vanilla message you wish to replace. </td></tr>
    <tr><td class="paramname">buf</td><td>The message buffer to copy from. </td></tr>
    <tr><td class="paramname">callback</td><td>A function pointer to call right before this text is displayed. Useful for dynamic text. Set as NULL if you don't want to use a callback. See <code><a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5" title="The function pointer type for message callbacks.">EZTR_MsgCallback</a></code> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52a12f735129bbe48bc0780c47fa7665" name="a52a12f735129bbe48bc0780c47fa7665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a12f735129bbe48bc0780c47fa7665">&#9670;&#160;</a></span>EZTR_Basic_ReplaceCustomBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_Basic_ReplaceCustomBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af14c939010aeb8ff548788278b5e1b0f">EZTR_CustomMsgHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare a replacement for a custom message by copying from a buffer defined by the user. </p>
<p>If you've defined a message using the MsgBuffer/MsgSContent functions, you can use this to set it (or, rather, a copy of it) as the new message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle for the message being replaced. </td></tr>
    <tr><td class="paramname">buf</td><td>The message buffer to copy from. </td></tr>
    <tr><td class="paramname">callback</td><td>A function pointer to call right before this text is displayed. Useful for dynamic text. Set as NULL if you don't want to use a callback. See <code><a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5" title="The function pointer type for message callbacks.">EZTR_MsgCallback</a></code> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc25b8ecceac76911ea9dfc91d94d9e8" name="abc25b8ecceac76911ea9dfc91d94d9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc25b8ecceac76911ea9dfc91d94d9e8">&#9670;&#160;</a></span>EZTR_Basic_ReplaceCustomText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_Basic_ReplaceCustomText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af14c939010aeb8ff548788278b5e1b0f">EZTR_CustomMsgHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>text_box_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>text_box_y_pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>display_icon</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>next_message_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>first_item_rupees</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>second_item_rupees</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>pipe_escape_bytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>content</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare a replacement of a custom message by defining the header attributes and message content. </p>
<p>This is probably the easiest method to replace custom messages, even those defined by other mods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle for the message being replaced. </td></tr>
    <tr><td class="paramname">text_box_type</td><td>The style of textbox to display. Use the <code><a class="el" href="#ac7a0819ee2ed5d0e939030ae98b9171c" title="Used in the message header to indicate the style of textbox used for the message.">EZTR_TextBoxType</a></code> enum for more readable values. </td></tr>
    <tr><td class="paramname">text_box_y_pos</td><td>The vertical position of the textbox on-screen. </td></tr>
    <tr><td class="paramname">display_icon</td><td>Displays an icon in the textbox. Use the <code><a class="el" href="#a716ef28fc50ca98601dddf9fb05240cb" title="Used in the message header to indicate a display icon for the message.">EZTR_TextBoxIcon</a></code> enum for more readable values. Use <code>EZTR_ICON_NO_ICON</code> for no icon. </td></tr>
    <tr><td class="paramname">next_message_id</td><td>The next message to display. If there is no next message, or the next message is determined by code, use 0xFFFF or <code>EZTR_NO_VALUE</code>. </td></tr>
    <tr><td class="paramname">first_item_rupees</td><td>The price of the first item being offered for sale, if one exists. If there is no item, use 0xFFFF or <code>EZTR_NO_VALUE</code>. </td></tr>
    <tr><td class="paramname">second_item_rupees</td><td>The price of the second item being offered for sale, if one exists. If there is no item, use 0xFFFF or <code>EZTR_NO_VALUE</code>. </td></tr>
    <tr><td class="paramname">pipe_escape_bytes</td><td>If true, <code>content</code> is passed through <code>EZTR_MsgBuffer_Sprintf("%m", content)</code>. If false, then <code>content</code> is copied directly into storage. </td></tr>
    <tr><td class="paramname">content</td><td>The new text content to display. If you want empty content (for use with dynamic messages), use "\xBF". </td></tr>
    <tr><td class="paramname">callback</td><td>A function pointer to call right before this text is displayed. Useful for dynamic messages. Set as NULL if you don't want to use a callback. See <code><a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5" title="The function pointer type for message callbacks.">EZTR_MsgCallback</a></code> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac21eaf9a0b5b451ff82363418ce9eb10" name="ac21eaf9a0b5b451ff82363418ce9eb10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21eaf9a0b5b451ff82363418ce9eb10">&#9670;&#160;</a></span>EZTR_Basic_ReplaceCustomTextEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_Basic_ReplaceCustomTextEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af14c939010aeb8ff548788278b5e1b0f">EZTR_CustomMsgHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare a replacement of a custom message, where the replacement message is empty. </p>
<p>This is primarily used if you want the message to be completely dynamically generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle for the message being replaced. </td></tr>
    <tr><td class="paramname">callback</td><td>A function pointer to call right before this text is displayed, in which you will construct the complete message buffer dynamically. See <code><a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5" title="The function pointer type for message callbacks.">EZTR_MsgCallback</a></code> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a130700fec5bb6f9469a5c41847f2fbb6" name="a130700fec5bb6f9469a5c41847f2fbb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130700fec5bb6f9469a5c41847f2fbb6">&#9670;&#160;</a></span>EZTR_Basic_ReplaceText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_Basic_ReplaceText </td>
          <td>(</td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>textId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>text_box_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>text_box_y_pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>display_icon</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>next_message_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>first_item_rupees</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>second_item_rupees</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>pipe_escape_bytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>content</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare a replacement of a vanilla message by defining the header attributes and message content. </p>
<p>This is probably the easiest method to declare replacement text.</p>
<p>Note that this function is meant for replacing vanilla messages only. It will not allow you to use a textId greater than 0x354C, as that is the highest textId value found in the vanilla game. If you wish to create/modify a custom message, see <code><a class="el" href="#aba5d26d7477edd4ba4ec2be15766e136" title="Declare a brand new (i.e: custom) message by defining the header attributes and message content.">EZTR_Basic_AddCustomText()</a></code> and <a class="el" href="#abc25b8ecceac76911ea9dfc91d94d9e8" title="Declare a replacement of a custom message by defining the header attributes and message content.">EZTR_Basic_ReplaceCustomText()</a>`</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textId</td><td>The id of the vanilla message you wish to replace. </td></tr>
    <tr><td class="paramname">text_box_type</td><td>The style of textbox to display. Use the <code><a class="el" href="#ac7a0819ee2ed5d0e939030ae98b9171c" title="Used in the message header to indicate the style of textbox used for the message.">EZTR_TextBoxType</a></code> enum for more readable values. </td></tr>
    <tr><td class="paramname">text_box_y_pos</td><td>The vertical position of the textbox on-screen. </td></tr>
    <tr><td class="paramname">display_icon</td><td>Displays an icon in the textbox. Use the <code><a class="el" href="#a716ef28fc50ca98601dddf9fb05240cb" title="Used in the message header to indicate a display icon for the message.">EZTR_TextBoxIcon</a></code> enum for more readable values. Use <code>EZTR_ICON_NO_ICON</code> for no icon. </td></tr>
    <tr><td class="paramname">next_message_id</td><td>The next message to display. If there is no next message, or the next message is determined by code, use 0xFFFF or <code>EZTR_NO_VALUE</code>. </td></tr>
    <tr><td class="paramname">first_item_rupees</td><td>The price of the first item being offered for sale, if one exists. If there is no item, use 0xFFFF or <code>EZTR_NO_VALUE</code>. </td></tr>
    <tr><td class="paramname">second_item_rupees</td><td>The price of the second item being offered for sale, if one exists. If there is no item, use 0xFFFF or <code>EZTR_NO_VALUE</code>. </td></tr>
    <tr><td class="paramname">pipe_escape_bytes</td><td>If true, <code>content</code> is passed through <code>EZTR_MsgBuffer_Sprintf("%m", content)</code>. If false, then <code>content</code> is copied directly into storage. </td></tr>
    <tr><td class="paramname">content</td><td>The new text content to display. If you want empty content (for use with dynamic messages), use "\xBF". </td></tr>
    <tr><td class="paramname">callback</td><td>A function pointer to call right before this text is displayed. Useful for dynamic messages. Set as NULL if you don't want to use a callback. See <code><a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5" title="The function pointer type for message callbacks.">EZTR_MsgCallback</a></code> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c3d2fef5e69105140806673fce4d985" name="a2c3d2fef5e69105140806673fce4d985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3d2fef5e69105140806673fce4d985">&#9670;&#160;</a></span>EZTR_Basic_ReplaceTextEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_Basic_ReplaceTextEmpty </td>
          <td>(</td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>textId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5">EZTR_MsgCallback</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare a replacement of a vanilla message, where the replacement message is empty. </p>
<p>This is primarily used if you want the message to be completely dynamically generated.</p>
<p>Note that this function is meant for replacing vanilla messages only. It will not allow you to use a textId greater than 0x354C, as that is the highest textId value found in the vanilla game. If you wish to create/modify a custom message, see <code><a class="el" href="#aed8bd9e796160a2657adf03a77703baf" title="Declare a brand new (i.e: custom) message, where the replacement message is empty.">EZTR_Basic_AddCustomTextEmpty()</a></code> and <a class="el" href="#ac21eaf9a0b5b451ff82363418ce9eb10" title="Declare a replacement of a custom message, where the replacement message is empty.">EZTR_Basic_ReplaceCustomTextEmpty()</a>`</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textId</td><td>The id of the vanilla message you wish to replace. </td></tr>
    <tr><td class="paramname">callback</td><td>A function pointer to call right before this text is displayed, in which you will construct the complete message buffer dynamically. See <code><a class="el" href="#ad9ba35ad8684a0265d641043caa81bc5" title="The function pointer type for message callbacks.">EZTR_MsgCallback</a></code> for more information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4370a73be9636af6f60dfb954342cedc" name="a4370a73be9636af6f60dfb954342cedc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4370a73be9636af6f60dfb954342cedc">&#9670;&#160;</a></span>EZTR_MsgBuffer_ContentLen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 EZTR_MsgBuffer_ContentLen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of the message buffer's content region, in bytes. </p>
<p>Effectively <code>EZTR_MsgBuffer_Len(buf) - 11</code> or <code>EZTR_MsgSContent_Len(buf-&gt;partition.content)</code>. Does not include the termination character '\xBF'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to measure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u32 The number of bytes the message buffer's content takes up. </dd></dl>

</div>
</div>
<a id="a020cddc8868430e6afd77733907d6139" name="a020cddc8868430e6afd77733907d6139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020cddc8868430e6afd77733907d6139">&#9670;&#160;</a></span>EZTR_MsgBuffer_Copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 EZTR_MsgBuffer_Copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from <code>src</code> into the message buffer <code>dst</code>. </p>
<p>Unlike something like <code>strcoy()</code>, this method is safe as long as dst is a full-sized message buffer, as it will not copy beyond the message buffer size.</p>
<p>Because <code>src</code> is expected to have a header region, the message termination characters '\xBF' are ignored for the first 11 bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The message buffer to copy into. </td></tr>
    <tr><td class="paramname">src</td><td>The data to copy. If you want to copy from another message buffer, use <code>src-&gt;raw.schar</code> or typecast src as <code>char*</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u32 The number of bytes copied. </dd></dl>

</div>
</div>
<a id="a39c2beef126a75f0222b69759008120e" name="a39c2beef126a75f0222b69759008120e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c2beef126a75f0222b69759008120e">&#9670;&#160;</a></span>EZTR_MsgBuffer_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> * EZTR_MsgBuffer_Create </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new message buffer object on the heap. </p>
<p>The created buffer will be have a default header and an empty content region. You need to free any buffer you create using this function with <code><a class="el" href="#a27b268a005666834e39511fd0dc2c469" title="Frees/destroys a message buffer.">EZTR_MsgBuffer_Destroy()</a></code>, or else you will create a memory leak.</p>
<dl class="section return"><dt>Returns</dt><dd>MsgBuffer* A pointer to the buffer you created. </dd></dl>

</div>
</div>
<a id="a09fc35479c7e6fee9e6049f473363177" name="a09fc35479c7e6fee9e6049f473363177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09fc35479c7e6fee9e6049f473363177">&#9670;&#160;</a></span>EZTR_MsgBuffer_CreateFromStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> * EZTR_MsgBuffer_CreateFromStr </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new message buffer object on the heap, and copies <code>src</code> into it. </p>
<p>Equivalent to <code>buf = <a class="el" href="#a39c2beef126a75f0222b69759008120e" title="Creates a new message buffer object on the heap.">EZTR_MsgBuffer_Create()</a>; EZTR_MsgBuffer_Copy(buf);</code></p>
<p>You need to free any buffer you create using this function with <code><a class="el" href="#a27b268a005666834e39511fd0dc2c469" title="Frees/destroys a message buffer.">EZTR_MsgBuffer_Destroy()</a></code>, or else you will create a memory leak.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The content to copy into the buffer. Expected to have a header region, and be terminated with '\xBF'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MsgBuffer* A pointer to the buffer you created. </dd></dl>

</div>
</div>
<a id="a91896add7333589c5d04730e84c8f6f4" name="a91896add7333589c5d04730e84c8f6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91896add7333589c5d04730e84c8f6f4">&#9670;&#160;</a></span>EZTR_MsgBuffer_CreateFromStrN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> * EZTR_MsgBuffer_CreateFromStrN </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new message buffer object on the heap, and copies <code>src</code> into it for up to <code>len</code> bytes. </p>
<p>Equivalent to <code>buf = <a class="el" href="#a39c2beef126a75f0222b69759008120e" title="Creates a new message buffer object on the heap.">EZTR_MsgBuffer_Create()</a>; EZTR_MsgBuffer_CopyN(buf, len);</code></p>
<p>You need to free any buffer you create using this function with <code><a class="el" href="#a27b268a005666834e39511fd0dc2c469" title="Frees/destroys a message buffer.">EZTR_MsgBuffer_Destroy()</a></code>, or else you will create a memory leak.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The content to copy into the buffer. Expected to have a header region, and be terminated with '\xBF'. </td></tr>
    <tr><td class="paramname">len</td><td>The maximum number of bytes to copy. If a '\xBF<code>is encountered in the content region of</code>src<code>, the function will stop copying before</code>len` is reached. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MsgBuffer* A pointer to the buffer you created. </dd></dl>

</div>
</div>
<a id="a27b268a005666834e39511fd0dc2c469" name="a27b268a005666834e39511fd0dc2c469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b268a005666834e39511fd0dc2c469">&#9670;&#160;</a></span>EZTR_MsgBuffer_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_MsgBuffer_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees/destroys a message buffer. </p>
<p>EZTR only expects you to destroy buffers that you create youself using one of the above functions.A_BTN_STATE_IDLE Buffers given to you by in <code>MsgCallback</code> functions are created and destroyed by EZTR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>A pointer to the message buffer to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21eec47bd44a5a81b37aa88561d17146" name="a21eec47bd44a5a81b37aa88561d17146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21eec47bd44a5a81b37aa88561d17146">&#9670;&#160;</a></span>EZTR_MsgBuffer_GetContentPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * EZTR_MsgBuffer_GetContentPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a pointer to the beginning of the content region for a desired message buffer. </p>
<p>Equivalent to <code>buf-&gt;partition.content</code>, or <code>buf-&gt;data.content</code> assuming EZTR_MsgBufferData is being packed correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to get the the content from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char* The beginning of the message buffer's content region. </dd></dl>

</div>
</div>
<a id="aecbd0e2114b2169dac0254e15bb920f4" name="aecbd0e2114b2169dac0254e15bb920f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecbd0e2114b2169dac0254e15bb920f4">&#9670;&#160;</a></span>EZTR_MsgBuffer_GetFirstItemRupees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 EZTR_MsgBuffer_GetFirstItemRupees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the first_item_rupees from a message buffer's header. </p>
<p>Useful if your compiler is having trouble with the <code>__attribute_((packed))</code> on <code>EZTR_MsgBufferData</code>, and the data isn't lining up correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u16 The first_item_rupees of the message buffer. If <code>EZTR_MsgBufferData</code> is being packed correctly, this will be equivalent to <code>buf-&gt;data.first_item_rupees</code>. </dd></dl>

</div>
</div>
<a id="a015f838b68601c44d38be12780cb0834" name="a015f838b68601c44d38be12780cb0834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015f838b68601c44d38be12780cb0834">&#9670;&#160;</a></span>EZTR_MsgBuffer_GetNextMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 EZTR_MsgBuffer_GetNextMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the next_message_id from a message buffer's header. </p>
<p>Useful if your compiler is having trouble with the <code>__attribute_((packed))</code> on <code>EZTR_MsgBufferData</code>, and the data isn't lining up correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u16 The display_icon of the message buffer. If <code>EZTR_MsgBufferData</code> is being packed correctly, this will be equivalent to <code>buf-&gt;data.next_message_id</code>. </dd></dl>

</div>
</div>
<a id="aa2894fa932a1b5ab0429b26395eca921" name="aa2894fa932a1b5ab0429b26395eca921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2894fa932a1b5ab0429b26395eca921">&#9670;&#160;</a></span>EZTR_MsgBuffer_GetSecondItemRupees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 EZTR_MsgBuffer_GetSecondItemRupees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the second_item_rupees from a message buffer's header. </p>
<p>Useful if your compiler is having trouble with the <code>__attribute_((packed))</code> on <code>EZTR_MsgBufferData</code>, and the data isn't lining up correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u16 The second_item_rupees of the message buffer. If <code>EZTR_MsgBufferData</code> is being packed correctly, this will be equivalent to <code>buf-&gt;data.second_item_rupees</code>. </dd></dl>

</div>
</div>
<a id="a4bc50f85b99782d5aa97f8d122d1587d" name="a4bc50f85b99782d5aa97f8d122d1587d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc50f85b99782d5aa97f8d122d1587d">&#9670;&#160;</a></span>EZTR_MsgBuffer_GetTextBoxDisplayIcon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 EZTR_MsgBuffer_GetTextBoxDisplayIcon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the display_icon from a message buffer's header. </p>
<p>Useful if your compiler is having trouble with the <code>__attribute_((packed))</code> on <code>EZTR_MsgBufferData</code>, and the data isn't lining up correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u8 The display_icon of the message buffer. If <code>EZTR_MsgBufferData</code> is being packed correctly, this will be equivalent to <code>buf-&gt;data.display_icon</code>. </dd></dl>

</div>
</div>
<a id="a6fa740d70e876eb91c758c0686f06cb6" name="a6fa740d70e876eb91c758c0686f06cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa740d70e876eb91c758c0686f06cb6">&#9670;&#160;</a></span>EZTR_MsgBuffer_GetTextBoxType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 EZTR_MsgBuffer_GetTextBoxType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the text_box_type from a message buffer's header. </p>
<p>Useful if your compiler is having trouble with the <code>__attribute_((packed))</code> on <code>EZTR_MsgBufferData</code>, and the data isn't lining up correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u8 The text_box_type of the message buffer. If <code>EZTR_MsgBufferData</code> is being packed correctly, this will be equivalent to <code>buf-&gt;data.text_box_type</code>. </dd></dl>

</div>
</div>
<a id="acb5e6b7691b750e998d5258cd180ef8e" name="acb5e6b7691b750e998d5258cd180ef8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb5e6b7691b750e998d5258cd180ef8e">&#9670;&#160;</a></span>EZTR_MsgBuffer_GetTextBoxYPos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 EZTR_MsgBuffer_GetTextBoxYPos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the text_box_y_pos from a message buffer's header. </p>
<p>Useful if your compiler is having trouble with the <code>__attribute_((packed))</code> on <code>EZTR_MsgBufferData</code>, and the data isn't lining up correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u8 The text_box_y_pos of the message buffer. If <code>EZTR_MsgBufferData</code> is being packed correctly, this will be equivalent to <code>buf-&gt;data.text_box_y_pos</code>. </dd></dl>

</div>
</div>
<a id="a8b931bdaf93270ddc7ed445cf699b1fe" name="a8b931bdaf93270ddc7ed445cf699b1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b931bdaf93270ddc7ed445cf699b1fe">&#9670;&#160;</a></span>EZTR_MsgBuffer_Len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 EZTR_MsgBuffer_Len </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of the message buffer's stored data, in bytes. </p>
<p>Does not include the termination character '\xBF'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to measure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u32 The number of bytes the message buffer's data takes up. </dd></dl>

</div>
</div>
<a id="aa46abdcae0cc0572a9b3d6474f01bc62" name="aa46abdcae0cc0572a9b3d6474f01bc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa46abdcae0cc0572a9b3d6474f01bc62">&#9670;&#160;</a></span>EZTR_MsgBuffer_NCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 EZTR_MsgBuffer_NCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from <code>src</code> into the message buffer <code>dst</code>, up to <code>len</code> bytes. </p>
<p>Because <code>src</code> is expected to have a header region, the message termination characters '\xBF' are ignored for the first 11 bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The message buffer to copy into. </td></tr>
    <tr><td class="paramname">src</td><td>The data to copy. If you want to copy from another message buffer, use <code>src-&gt;raw.schar</code> or typecast src as <code>char*</code>. </td></tr>
    <tr><td class="paramname">len</td><td>The maximum number of bytes to copy. If a '\xBF<code>is encountered in the content region of</code>src<code>, the function will stop copying before</code>len` is reached. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u32 The number of bytes copied. </dd></dl>

</div>
</div>
<a id="af8d9e959cd5fa20e5bdadb8cce347c22" name="af8d9e959cd5fa20e5bdadb8cce347c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d9e959cd5fa20e5bdadb8cce347c22">&#9670;&#160;</a></span>EZTR_MsgBuffer_Print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_MsgBuffer_Print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the contents of a message buffer to the console. </p>
<p>Each value in the header will be labeled. The content region will stop printing after the '\xBF' termination character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59379a5596f63ec6c0bcd7eb4fb7fd14" name="a59379a5596f63ec6c0bcd7eb4fb7fd14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59379a5596f63ec6c0bcd7eb4fb7fd14">&#9670;&#160;</a></span>EZTR_MsgBuffer_PrintFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_MsgBuffer_PrintFull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the contents of a message buffer to the console. </p>
<p>Each value in the header will be labeled. The this function prints the entire 1279 bytes of the content region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89663200d1aa9ffe42c27039bb2701d4" name="a89663200d1aa9ffe42c27039bb2701d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89663200d1aa9ffe42c27039bb2701d4">&#9670;&#160;</a></span>EZTR_MsgBuffer_SetFirstItemRupees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_MsgBuffer_SetFirstItemRupees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the first_item_rupees of the message buffer's header. </p>
<p>Useful if your compiler is having trouble with the <code>__attribute_((packed))</code> on <code>EZTR_MsgBufferData</code>, and the data isn't lining up correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to write to. </td></tr>
    <tr><td class="paramname">value</td><td>The new first_item_rupees value. If <code>EZTR_MsgBufferData</code> is being packed correctly, this will be equivalent to <code>buf-&gt;data.first_item_rupees = icon</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46f857fd4054f0b076012a85b8b14f08" name="a46f857fd4054f0b076012a85b8b14f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f857fd4054f0b076012a85b8b14f08">&#9670;&#160;</a></span>EZTR_MsgBuffer_SetNextMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_MsgBuffer_SetNextMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>textId</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the next_message_id of the message buffer's header. </p>
<p>Useful if your compiler is having trouble with the <code>__attribute_((packed))</code> on <code>EZTR_MsgBufferData</code>, and the data isn't lining up correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to write to. </td></tr>
    <tr><td class="paramname">textId</td><td>The new display_icon value. If <code>EZTR_MsgBufferData</code> is being packed correctly, this will be equivalent to <code>buf-&gt;data.next_message_id = icon</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a873aabed87f63550b8818174e16f7f63" name="a873aabed87f63550b8818174e16f7f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873aabed87f63550b8818174e16f7f63">&#9670;&#160;</a></span>EZTR_MsgBuffer_SetSecondItemRupees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_MsgBuffer_SetSecondItemRupees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the second_item_rupees of the message buffer's header. </p>
<p>Useful if your compiler is having trouble with the <code>__attribute_((packed))</code> on <code>EZTR_MsgBufferData</code>, and the data isn't lining up correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to write to. </td></tr>
    <tr><td class="paramname">value</td><td>The new second_item_rupees value. If <code>EZTR_MsgBufferData</code> is being packed correctly, this will be equivalent to <code>buf-&gt;data.second_item_rupees = icon</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf6d8ba4bde04faab7330540c4d284cd" name="acf6d8ba4bde04faab7330540c4d284cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6d8ba4bde04faab7330540c4d284cd">&#9670;&#160;</a></span>EZTR_MsgBuffer_SetTextBoxDisplayIcon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_MsgBuffer_SetTextBoxDisplayIcon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>icon</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the display_icon of the message buffer's header. </p>
<p>Useful if your compiler is having trouble with the <code>__attribute_((packed))</code> on <code>EZTR_MsgBufferData</code>, and the data isn't lining up correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to write to. </td></tr>
    <tr><td class="paramname">icon</td><td>The new display_icon value. If <code>EZTR_MsgBufferData</code> is being packed correctly, this will be equivalent to <code>buf-&gt;data.display_icon = icon</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a530d275045043f28d94b762b36daf66e" name="a530d275045043f28d94b762b36daf66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530d275045043f28d94b762b36daf66e">&#9670;&#160;</a></span>EZTR_MsgBuffer_SetTextBoxType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_MsgBuffer_SetTextBoxType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the text_box_type of the message buffer's header. </p>
<p>Useful if your compiler is having trouble with the <code>__attribute_((packed))</code> on <code>EZTR_MsgBufferData</code>, and the data isn't lining up correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to write to. </td></tr>
    <tr><td class="paramname">type</td><td>The new text_box_type value. If <code>EZTR_MsgBufferData</code> is being packed correctly, this will be equivalent to <code>buf-&gt;data.text_box_type = type</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abaf1d5e1b0fc9637427f0c758bff0da9" name="abaf1d5e1b0fc9637427f0c758bff0da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf1d5e1b0fc9637427f0c758bff0da9">&#9670;&#160;</a></span>EZTR_MsgBuffer_SetTextBoxYPos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_MsgBuffer_SetTextBoxYPos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the text_box_y_pos of the message buffer's header. </p>
<p>Useful if your compiler is having trouble with the <code>__attribute_((packed))</code> on <code>EZTR_MsgBufferData</code>, and the data isn't lining up correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The message buffer to write to. </td></tr>
    <tr><td class="paramname">pos</td><td>The new text_box_y_pos value. If <code>EZTR_MsgBufferData</code> is being packed correctly, this will be equivalent to <code>buf-&gt;data.text_box_y_pos = pos</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad149fb2e9d2c8fa3e0034ac54a61a678" name="ad149fb2e9d2c8fa3e0034ac54a61a678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad149fb2e9d2c8fa3e0034ac54a61a678">&#9670;&#160;</a></span>EZTR_MsgBuffer_WriteDefaultHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_MsgBuffer_WriteDefaultHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a message buffer's header to default values. </p>
<p>The default values for a message buffer header are:</p>
<ul>
<li>text_box_type = EZTR_STANDARD_TEXT_BOX_I (0)</li>
<li>text_box_y_pos = 0</li>
<li>display_icon = EZTR_ICON_NO_ICON (0xFE)</li>
<li>next_message_id = EZTR_NO_VALUE (0xFFFF)</li>
<li>first_item_rupees = EZTR_NO_VALUE (0xFFFF)</li>
<li>second_item_rupees = EZTR_NO_VALUE (0xFFFF)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the message buffer to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a578d94107d666a42c08bb3ad73fd8f33" name="a578d94107d666a42c08bb3ad73fd8f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a578d94107d666a42c08bb3ad73fd8f33">&#9670;&#160;</a></span>EZTR_MsgBuffer_WriteHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_MsgBuffer_WriteHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_e_z_t_r___msg_buffer.html">EZTR_MsgBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>text_box_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>text_box_y_pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8</td>          <td class="paramname"><span class="paramname"><em>display_icon</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>next_message_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>first_item_rupees</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16</td>          <td class="paramname"><span class="paramname"><em>second_item_rupees</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the message buffer to write to. </td></tr>
    <tr><td class="paramname">text_box_type</td><td>The style of textbox to display. Use the <code><a class="el" href="#ac7a0819ee2ed5d0e939030ae98b9171c" title="Used in the message header to indicate the style of textbox used for the message.">EZTR_TextBoxType</a></code> enum for more readable values. </td></tr>
    <tr><td class="paramname">text_box_y_pos</td><td>The vertical position of the textbox on-screen. </td></tr>
    <tr><td class="paramname">display_icon</td><td>Displays an icon in the textbox. Use the <code><a class="el" href="#a716ef28fc50ca98601dddf9fb05240cb" title="Used in the message header to indicate a display icon for the message.">EZTR_TextBoxIcon</a></code> enum for more readable values. Use <code>EZTR_ICON_NO_ICON</code> for no icon. </td></tr>
    <tr><td class="paramname">next_message_id</td><td>The next message to display. If there is no next message, or the next message is determined by code, use 0xFFFF or <code>EZTR_NO_VALUE</code>. </td></tr>
    <tr><td class="paramname">first_item_rupees</td><td>The price of the first item being offered for sale, if one exists. If there is no item, use 0xFFFF or <code>EZTR_NO_VALUE</code>. </td></tr>
    <tr><td class="paramname">second_item_rupees</td><td>The price of the second item being offered for sale, if one exists. If there is no item, use 0xFFFF or <code>EZTR_NO_VALUE</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72647d2cb1cbb660f9cb86df6074241f" name="a72647d2cb1cbb660f9cb86df6074241f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72647d2cb1cbb660f9cb86df6074241f">&#9670;&#160;</a></span>EZTR_MsgSContent_Cat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * EZTR_MsgSContent_Cat </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the message content of <code>src</code> onto the end of <code>dst</code>. </p>
<p>Similar to <code>strcat()</code> for null-terminated strings.</p>
<p>This function is safe as long as <code>dst</code> points to the beginning of a message buffer's content region, as it will not produce message content larger than a message buffer's content region. Copying will stop once the maximum size is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The location to append message content into. </td></tr>
    <tr><td class="paramname">src</td><td>The message content to copy. Should be '\xBF' terminated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char* The pointer to the new string (i.e: to <code>dst</code>). </dd></dl>

</div>
</div>
<a id="aedf2e411789c0ad0061471c74ba87204" name="aedf2e411789c0ad0061471c74ba87204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf2e411789c0ad0061471c74ba87204">&#9670;&#160;</a></span>EZTR_MsgSContent_Cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 EZTR_MsgSContent_Cmp </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two message content strings. </p>
<p>This function is safe as long as both <code>str1</code> and <code>str2</code> point to the content region of message buffers, as the comparison will not continue beyond that size.</p>
<p>Similar to <code>strcmp()</code> for null-terminated strings, but with one notable difference: With <code>strncmp()</code>, if two strings are equal for the first <code>n</code> characters, but one string continues after <code>n</code> while <br  />
 the other doesn't, the shorter string is considered 'lesser' because the null terminator &lsquo;&rsquo;\x00'<code>is naturally the lowest possible ASCII value. Because strings in MM are</code>'\XBF'` terminated, that behavior won't apply here.</p>
<p>In <code><a class="el" href="#aedf2e411789c0ad0061471c74ba87204" title="Compares two message content strings.">EZTR_MsgSContent_Cmp()</a></code>, a special case is applied: If two strings are equal for <code>n</code> characters, but the next character after <code>n</code> is &lsquo;&rsquo;\XBF'` in one of the strings, it is considered the lesser string regardless of what the other character is.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>The first message content string to compare. </td></tr>
    <tr><td class="paramname">str2</td><td>The second message content string to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>s32 Returns 0 is the strings are the same, 1 if the first string is greater than the second, and -1 if the second string is greater than the first. </dd></dl>

</div>
</div>
<a id="a663aa64051a106585368bd080dbfac91" name="a663aa64051a106585368bd080dbfac91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a663aa64051a106585368bd080dbfac91">&#9670;&#160;</a></span>EZTR_MsgSContent_Copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 EZTR_MsgSContent_Copy </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies message content from <code>src</code> into the <code>dst</code>. </p>
<p>Similar to <code>strcpy()</code> for null-terminated strings.</p>
<p>This function is safe as long as <code>dst</code> points to the beginning of a message buffer's content region, since it will not copy bytes beyond that size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The location to copy message content into. </td></tr>
    <tr><td class="paramname">src</td><td>The message content to copy. Should be '\xBF' terminated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u32 The number of bytes copied. </dd></dl>

</div>
</div>
<a id="a34be36f8427a9e5af06d8b3dabcf34c2" name="a34be36f8427a9e5af06d8b3dabcf34c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34be36f8427a9e5af06d8b3dabcf34c2">&#9670;&#160;</a></span>EZTR_MsgSContent_Fctprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EZTR_MsgSContent_Fctprintf </td>
          <td>(</td>
          <td class="paramtype">void(*</td>          <td class="paramname"><span class="paramname"><em>out&#160;</em></span>)(char character, void *arg), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A modified version of printf, specially designed to handle message content. </p>
<p>see <a class="el" href="prinf_functions.html">EZTR Printf Functions</a> for more information on EZTR's custom printf behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
    <tr><td class="paramname">arg</td><td></td></tr>
    <tr><td class="paramname">format</td><td></td></tr>
    <tr><td class="paramname">...</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="affede5c9bbcd94fcedf72680c6ac3666" name="affede5c9bbcd94fcedf72680c6ac3666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affede5c9bbcd94fcedf72680c6ac3666">&#9670;&#160;</a></span>EZTR_MsgSContent_Len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 EZTR_MsgSContent_Len </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cont</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the length of the a message content string in bytes, not counting the '\xBF' termination character. </p>
<p>Similar to <code>strlen()</code> for null-terminated strings.</p>
<p>This function is safe as long as <code>cont</code> points to the beginning of a message buffer's content region, since it will not count bytes beyond that size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>The message content you want to get the length of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u32 The length of the message content, in bytes. </dd></dl>

</div>
</div>
<a id="aa144e4595b017537667babed825e67eb" name="aa144e4595b017537667babed825e67eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa144e4595b017537667babed825e67eb">&#9670;&#160;</a></span>EZTR_MsgSContent_NCat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * EZTR_MsgSContent_NCat </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the message content of <code>src</code> onto the end of <code>dst</code>, up to <code>len</code> bytes from <code>src</code>. </p>
<p>Similar to <code>strncat()</code> for null-terminated strings.</p>
<p>This function will not produce message content larger than a message buffer's content region. Copying will stop once the maximum size is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The location to append message content into. </td></tr>
    <tr><td class="paramname">src</td><td>The message content to copy. </td></tr>
    <tr><td class="paramname">len</td><td>The maximum number of bytes to copy. If a '\xBF' is encountered in <code>src</code>, the function will stop copying before <code>len</code> is reached. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char* The pointer to the new string (i.e: to <code>dst</code>). </dd></dl>

</div>
</div>
<a id="a79545ea629e4fb127ad978a8518c310f" name="a79545ea629e4fb127ad978a8518c310f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79545ea629e4fb127ad978a8518c310f">&#9670;&#160;</a></span>EZTR_MsgSContent_NCmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 EZTR_MsgSContent_NCmp </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares up to <code>len</code> bytes of two message content strings. </p>
<p>Similar to <code>strncmp()</code> for null-terminated strings, but with one notable difference: With <code>strncmp()</code>, if two strings are equal for the first <code>n</code> characters, but one string continues after <code>n</code> while <br  />
 the other doesn't, the shorter string is considered 'lesser' because the null terminator &lsquo;&rsquo;\x00'<code>is naturally the lowest possible ASCII value. Because strings in MM are</code>'\XBF'` terminated, that behavior won't apply here.</p>
<p>In <code><a class="el" href="#a79545ea629e4fb127ad978a8518c310f" title="Compares up to len bytes of two message content strings.">EZTR_MsgSContent_NCmp()</a></code>, a special case is applied: If two strings are equal for <code>n</code> characters, but the next character after <code>n</code> is &lsquo;&rsquo;\XBF'` in one of the strings, it is considered the lesser string regardless of what the other character is.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>The first message content string to compare. </td></tr>
    <tr><td class="paramname">str2</td><td>The second message content string to compare. </td></tr>
    <tr><td class="paramname">len</td><td>The maximum number of bytes to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>s32 Returns 0 is the strings are the same, 1 if the first string is greater than the second, and -1 if the second string is greater than the first. </dd></dl>

</div>
</div>
<a id="a942c2f98af6fe2a81428bdcfd8336183" name="a942c2f98af6fe2a81428bdcfd8336183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942c2f98af6fe2a81428bdcfd8336183">&#9670;&#160;</a></span>EZTR_MsgSContent_NCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 EZTR_MsgSContent_NCopy </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies message content from <code>src</code> into the <code>dst</code>, up to <code>len</code> bytes. </p>
<p>Similar to <code>strncpy()</code> for null-terminated strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The location to copy message content into. </td></tr>
    <tr><td class="paramname">src</td><td>The message content to copy. </td></tr>
    <tr><td class="paramname">len</td><td>The maximum number of bytes to copy. If a '\xBF' is encountered in <code>src</code>, the function will stop copying before <code>len</code> is reached. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u32 The number of bytes copied. </dd></dl>

</div>
</div>
<a id="a37a90a7c7b0c76188aedb8da5a39ec08" name="a37a90a7c7b0c76188aedb8da5a39ec08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37a90a7c7b0c76188aedb8da5a39ec08">&#9670;&#160;</a></span>EZTR_MsgSContent_Printf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EZTR_MsgSContent_Printf </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A modified version of printf, specially designed to handle message content. </p>
<p>see <a class="el" href="prinf_functions.html">EZTR Printf Functions</a> for more information on EZTR's custom printf behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td></td></tr>
    <tr><td class="paramname">...</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="ad1ff11ca18271df5512699d276b6ba1e" name="ad1ff11ca18271df5512699d276b6ba1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ff11ca18271df5512699d276b6ba1e">&#9670;&#160;</a></span>EZTR_MsgSContent_PrintfLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EZTR_MsgSContent_PrintfLine </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A modified version of printf, specially designed to handle message content. </p>
<p>see <a class="el" href="prinf_functions.html">EZTR Printf Functions</a> for more information on EZTR's custom printf behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td></td></tr>
    <tr><td class="paramname">...</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a9cdf97a6b5c9d99e1154d1709e6f2dc4" name="a9cdf97a6b5c9d99e1154d1709e6f2dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cdf97a6b5c9d99e1154d1709e6f2dc4">&#9670;&#160;</a></span>EZTR_MsgSContent_SetEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EZTR_MsgSContent_SetEmpty </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cont</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the message message content as empty.A_BTN_STATE_IDLE. </p>
<p>This is accomplished by setting the first character in the message content to the '\xBF' termination character. No other bytes are effected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>A pointer to message content string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7c28d2307ddff188da8705b7b426ceb" name="ac7c28d2307ddff188da8705b7b426ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7c28d2307ddff188da8705b7b426ceb">&#9670;&#160;</a></span>EZTR_MsgSContent_Snprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EZTR_MsgSContent_Snprintf </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A modified version of printf, specially designed to handle message content. </p>
<p>see <a class="el" href="prinf_functions.html">EZTR Printf Functions</a> for more information on EZTR's custom printf behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td></td></tr>
    <tr><td class="paramname">count</td><td></td></tr>
    <tr><td class="paramname">format</td><td></td></tr>
    <tr><td class="paramname">...</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="af9672989bc812f2b03a238fe422e2f19" name="af9672989bc812f2b03a238fe422e2f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9672989bc812f2b03a238fe422e2f19">&#9670;&#160;</a></span>EZTR_MsgSContent_Sprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EZTR_MsgSContent_Sprintf </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A modified version of printf, specially designed to handle message content. </p>
<p>Unlike <code><a class="el" href="#a37a90a7c7b0c76188aedb8da5a39ec08" title="A modified version of printf, specially designed to handle message content.">EZTR_MsgSContent_Printf()</a></code>, this function will append a newline to the end of console output.</p>
<p>see <a class="el" href="prinf_functions.html">EZTR Printf Functions</a> for more information on EZTR's custom printf behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td></td></tr>
    <tr><td class="paramname">format</td><td></td></tr>
    <tr><td class="paramname">...</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a9de78728bd6fb85269e97d135ec69180" name="a9de78728bd6fb85269e97d135ec69180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de78728bd6fb85269e97d135ec69180">&#9670;&#160;</a></span>EZTR_MsgSContent_Vprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EZTR_MsgSContent_Vprintf </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list</td>          <td class="paramname"><span class="paramname"><em>va</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A modified version of printf, specially designed to handle message content. </p>
<p>see <a class="el" href="prinf_functions.html">EZTR Printf Functions</a> for more information on EZTR's custom printf behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td></td></tr>
    <tr><td class="paramname">va</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a8d5300f9289c9d3ed0b64175aef3c8b8" name="a8d5300f9289c9d3ed0b64175aef3c8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5300f9289c9d3ed0b64175aef3c8b8">&#9670;&#160;</a></span>EZTR_MsgSContent_Vsnprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EZTR_MsgSContent_Vsnprintf </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list</td>          <td class="paramname"><span class="paramname"><em>va</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A modified version of printf, specially designed to handle message content. </p>
<p>see <a class="el" href="prinf_functions.html">EZTR Printf Functions</a> for more information on EZTR's custom printf behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td></td></tr>
    <tr><td class="paramname">count</td><td></td></tr>
    <tr><td class="paramname">format</td><td></td></tr>
    <tr><td class="paramname">va</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_00fe2e4c5783f3f1040ef198a22c5262.html">include_in_dependents</a></li><li class="navelem"><a class="el" href="eztr__api_8h.html">eztr_api.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
